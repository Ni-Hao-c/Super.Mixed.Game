untyped

global function ExtraAISpawner_Init

global function ExtraSpawner_SpawnDropShip
global function ExtraSpawner_SpawnDropPod

// normal spawn
global function ExtraSpawner_SpawnNPCInDropPod
global function ExtraSpawner_SpawnSpecialistGruntDropShip
global function ExtraSpawner_SpawnSpecialistGruntDropPod
global function ExtraSpawner_SpawnProwlerSquadDropPod
// titan spawn
global function ExtraSpawner_SpawnTitan
global function ExtraSpawner_SpawnTitanBT
global function ExtraSpawner_SpawnBossTitan
// unused spawn
global function ExtraSpawner_SpawnGunShip
// modded titan func
global function ExtraSpawner_RegisterToTitanSpawnList
global function ExtraSpawner_RegisterToBossTitanSpawnList

global function ExtraSpawner_SpawnPilotElite
global function ExtraSpawner_SpawnPilotCanEmbark
global function ExtraSpawner_SpawnTitanWithPilot
// these settings should be done in prematch, don't do it right after levelLoad
global function ExtraSpawner_SetNPCWeapons
global function ExtraSpawner_SetNPCAntiTitanWeapons
global function ExtraSpawner_SetNPCGrenadeWeapons
global function ExtraSpawner_SetNPCExtraWeaponMods // mods added by this func will be applies to npcs
// set up funcs
global function ExtraSpawner_ApplyNPCWeapons
global function ExtraSpawner_ApplyNPCGrenadeWeapon // grenade have to be given before DispatchSpawn()
global function ExtraSpawner_ApplyNPCExtraWeaponMods
global function ExtraSpawner_SetUpNPCPilot

global function ExtraSpawner_SpawnCarePackageToGetWeapons
// these settings should be done in prematch, don't do it right after levelLoad
global function ExtraSpawner_SetCarePackageWeapons
global function ExtraSpawner_SetCarePackageWeaponMods
global function ExtraSpawner_SetCarePackageWeaponModsMultiple

// tick reaper funcs
global function ExtraSpawner_SpawnReaperCanLaunchTicks
global function ExtraSpawner_ReaperTickLaunchThink

// npc handlers
// default handlers
global function ExtraSpawner_SquadHandler
global function ExtraSpawner_TitanHandler
global function ExtraSpawner_PilotHandler
global function ExtraSpawner_ReaperHandler
// handler overrides
global function ExtraSpawner_SetSquadHandlerFunc
global function ExtraSpawner_SetNPCHandlerFunc
// disabling default handlers
global function ExtraSpawner_StopDefaultHandler // can't stop squad handler

// these are no need to change
const asset CAREPACKAGE_MODEL = $"models/vehicle/escape_pod/escape_pod.mdl"

// basically medium animation pilots!
const array<asset> NPC_PILOT_ALLOWED_MODELS = 
[ 
	// note that only grunt models have proper animation for a npc
	$"models/humans/pilots/pilot_medium_stalker_m.mdl", 
	$"models/humans/pilots/pilot_medium_stalker_f.mdl", 
	$"models/humans/pilots/pilot_medium_geist_m.mdl", 
	$"models/humans/pilots/pilot_medium_geist_f.mdl", 
	$"models/humans/pilots/pilot_medium_reaper_m.mdl", 
	$"models/humans/pilots/pilot_medium_reaper_f.mdl",
	$"models/humans/pilots/sp_medium_geist_f.mdl", 
	$"models/humans/pilots/sp_medium_reaper_m.mdl", 
	$"models/humans/pilots/sp_medium_stalker_m.mdl" 
	/* // now leaving only mp pilot models, for others maybe spawn with their unique titans( like jack in bt, ash in ronin )
	$"models/humans/grunts/mlt_grunt_lmg.mdl", 
	$"models/humans/grunts/imc_grunt_lmg.mdl", 
	$"models/humans/grunts/imc_grunt_shield_captain.mdl", 
	$"models/Humans/heroes/imc_hero_ash.mdl", 
	$"models/Humans/heroes/imc_hero_blisk.mdl", 
	$"models/humans/heroes/mlt_hero_jack.mdl", 
	$"models/humans/heroes/mlt_hero_sarah.mdl", 
	*/
]

// for ExtraSpawner_SpawnTitan() picking random titans
struct TitanSpawnStruct
{
	string setFile = ""
	string aiSet = ""
	string executionRef = "" // funny with MeleeSyncedNPC
	// after being embarked by npcs
	string embarkedAiSet = ""
	string embarkedBehavior = ""
	string embarkedTitle = ""

	void functionref( entity ) loadoutFunction = null
	// team skin
	int imcSkinIndex = -1
	int mltSkinIndex = -1
}

// for ExtraSpawner_SpawnBossTitan() picking random titans
struct BossTitanSpawnStruct
{
	string bossName = ""

	string setFile = ""
	string aiSet = ""
	string behavior = ""
	string executionRef = "" // funny with MeleeSyncedNPC
	string bossTitle = ""
	string pilotTitle = ""
	asset characterModel = $""

	void functionref( entity ) loadoutFunction = null
	// skin
	int skinIndex = -1
	int decalIndex = -1
}

// after being embarked by npcs
struct EmbarkedNPCTitanStruct
{
	string embarkedAiSet = ""
	string embarkedBehavior = ""
	string embarkedTitle = ""
}

struct
{
	// npc weapons, should we add a struct to set up mods for them?
	table< string, array<string> > npcMainWeaponsTable
	table< string, array<string> > npcAntiTitanWeaponsTable
	table< string, array<string> > npcGrenadeWeaponsTable
	table< string, array<string> > npcExtraWeaponModsTable
	// npc titan settings
	table<entity, EmbarkedNPCTitanStruct> soulEmbarkedSettings
	// for ExtraSpawner_SpawnTitan() picking random titans
	table<string, TitanSpawnStruct> titanSpawnList
	// for ExtraSpawner_SpawnBossTitan() picking random titans
	table<string, BossTitanSpawnStruct> bossTitanSpawnList
	// for marking the npc as spawning from this file
	table<entity, bool> npcSpawnFromExtraSpawner
	// for marking the npc as one of prowler squad
	table<entity, bool> isProwlerSquadmate
	// scripted npc dialogue
	table<entity, float> npcDialogueNextAllowedTime
	table<entity, string> npcLastDialogue
	// npc handler func
	void functionref( array<entity> ) squadHandlerFunc
	table< string, void functionref( entity ) > npcHandlerFuncs

	// care package
	array<entity> usedplayer = []
	array<string> carePackageWeapons
	// now allowing every weapon to have a custom mod
	table< string, array<string> > carePackageWeaponMods
} file

void function ExtraAISpawner_Init()
{
	// intilize
	InitCarePackageDefaultSettings()
	InitDefaultNPCWeapons()
	InitDefaultTitanList()
	InitDefaultBossTitanList()
	InitDefaultNPCHandlerFunctions()
	// prowler
	ProwlerPrecache()
	// care package
	RegisterSignal( "PlayerUsedCarePackage" ) // for some grunt mode classes regen their ability?
	PrecacheModel( CAREPACKAGE_MODEL )
	// specialist grunts
	PrecacheModel( $"models/humans/grunts/imc_grunt_shield_captain.mdl" )
	// npc bt
	PrecacheModel( $"models/titans/buddy/titan_buddy.mdl" )
	// npc handlers
	RegisterSignal( "StopDefaultHandler" )
	// npc pilot thin
	RegisterSignal( "EmbarkedNPCTitanThink" )

	// this should be in _ai_pilots.gnut
	//RegisterSignal( "ForceStartMove" ) // the signal as been deleted
	
	if( GetMapName() != "mp_lobby" ) // prevent unable to enter lobby
	{
		AddCallback_OnNpcPilotBecomesTitan( OnNpcPilotBecomesTitan )
		AddCallback_OnNpcTitanBecomesPilot( OnNpcTitanBecomesPilot )
	}

	// if npc titan has a pilot inside, reset it's melee damageSourceId
	AddDamageCallbackSourceID( eDamageSourceId.auto_titan_melee, ApplyNormalMeleeIdToNPCTitan )
	// npc pilot score event, better be added by gamemodes
	//AddDeathCallback( "npc_pilot_elite", KilledNPCPilotScoreEvent )
	// npc prowler: scale damage depend on model scale
	AddDamageCallbackSourceID( eDamageSourceId.prowler_melee, ProwlerMeleeDamageModifier )

	// convert imc stalkers to white ones
	// this is hardcode and not vanilla behavior.. just want to add some funny stuff		
	AddSpawnCallback( "npc_stalker", OnStalkerSpawned )

	// for debugging
	//MeleeSyncedNPC_EnableAll_Init()
	AddClientCommandCallback( "pilotandtitan", CC_SpawnPilotAndTitan )
	//AddClientCommandCallback( "tickreaper", CC_SpawnReaperCanLaunchTicks )
	//AddClientCommandCallback( "gunship", CC_SpawnGunShip )
	//AddClientCommandCallback( "assassinpilot", CC_SpawnAssassinPilot )
	//AddClientCommandCallback( "specialistgrunt", CC_SpawnSpecialistGrunt )
	//AddClientCommandCallback( "pilot", CC_SpawnPilotElite )
	//AddClientCommandCallback( "boss_intro", CC_SpawnBossTitanWithIntro )
	//AddClientCommandCallback( "pistol_grunt", CC_SpawnTestPistolGrunt )
}

void function OnStalkerSpawned( entity stalker )
{
	int team = stalker.GetTeam()
	if ( team == TEAM_IMC && stalker in file.npcSpawnFromExtraSpawner )
	{
		stalker.SetValueForModelKey( $"models/Robots/stalker/robot_stalker.mdl" )
		// the problem is we can't handle dropship condition, may break their animation
		// maybe just modify aisettings file?
		stalker.SetModel( $"models/Robots/stalker/robot_stalker.mdl" )
	}
}

void function ProwlerPrecache()
{
	// don't precache corpses again, or game's existing model will become errors!
    PrecacheModel($"models/creatures/prowler/r2_prowler.mdl")
}

// this is default settings, modders can change later
void function InitCarePackageDefaultSettings()
{
	// carepackage weapons
	// new grunt mode: only contains launchers
	file.carePackageWeapons =
	[
		"mp_weapon_epg", 
		"mp_weapon_softball", 
		"mp_weapon_pulse_lmg", 
		"mp_weapon_smr" 
	]

	// anti-titan
	file.carePackageWeaponMods["mp_weapon_arc_launcher"] <- [ "pas_fast_reload", "extended_ammo", "pas_fast_ads", "pas_fast_swap", "burn_mod_arc_launcher" ]
	file.carePackageWeaponMods["mp_weapon_mgl"] <- [ "pas_fast_reload", "extended_ammo", "pas_fast_ads", "pas_fast_swap", "burn_mod_mgl" ]
	file.carePackageWeaponMods["mp_weapon_rocket_launcher"] <- [ "pas_fast_reload", "extended_ammo", "pas_fast_ads", "pas_fast_swap", "burn_mod_rocket_launcher" ]
	file.carePackageWeaponMods["mp_weapon_defender"] <- [ "pas_fast_reload", "extended_ammo", "pas_fast_ads", "pas_fast_swap", "burn_mod_defender" ]

	// pistol
	file.carePackageWeaponMods["mp_weapon_autopistol"] <- [ "pas_fast_reload", "extended_ammo", "pas_fast_ads", "pas_run_and_gun", "burn_mod_autopistol" ]
	file.carePackageWeaponMods["mp_weapon_semipistol"] <- [ "pas_fast_reload", "extended_ammo", "pas_fast_ads", "pas_run_and_gun", "burn_mod_semipistol" ]
	file.carePackageWeaponMods["mp_weapon_smart_pistol"] <- [] 
	file.carePackageWeaponMods["mp_weapon_wingman"] <- [ "pas_fast_reload", "extended_ammo", "pas_fast_ads", "pas_run_and_gun", "burn_mod_wingman" ]
	file.carePackageWeaponMods["mp_weapon_wingman_n"] <- [ "pas_fast_reload", "extended_ammo", "pas_fast_ads", "pas_run_and_gun", ]
	file.carePackageWeaponMods["mp_weapon_shotgun_pistol"] <- [ "pas_fast_reload", "extended_ammo", "pas_fast_ads", "pas_run_and_gun", ] 

	// sniper
	file.carePackageWeaponMods["mp_weapon_doubletake"] <- [ "pas_fast_reload", "extended_ammo", "pas_fast_ads", "pas_fast_swap", "ricochet" ]
	file.carePackageWeaponMods["mp_weapon_sniper"] <- [ "pas_fast_reload", "extended_ammo", "pas_fast_ads", "ricochet", "pas_fast_swap", "burn_mod_sniper" ]
	file.carePackageWeaponMods["mp_weapon_dmr"] <- [ "pas_fast_reload", "extended_ammo", "pas_fast_ads" ] 
	
	// rifle
	file.carePackageWeaponMods["mp_weapon_vinson"] <- [ "pas_fast_reload", "extended_ammo", "pas_fast_ads", "pas_run_and_gun", "pas_fast_swap", "hcog" ] 
	file.carePackageWeaponMods["mp_weapon_rspn101"] <- [ "pas_fast_reload", "extended_ammo", "pas_fast_ads", "pas_run_and_gun", "pas_fast_swap", "hcog" ] 
	file.carePackageWeaponMods["mp_weapon_rspn101_og"] <- [ "pas_fast_reload", "extended_ammo", "pas_fast_ads", "pas_run_and_gun", "pas_fast_swap", "hcog" ] 
	file.carePackageWeaponMods["mp_weapon_g2"] <- [ "pas_fast_reload", "extended_ammo", "pas_fast_ads", "pas_run_and_gun", "pas_fast_swap", "hcog" ] 
	file.carePackageWeaponMods["mp_weapon_hemlok"] <- [ "pas_fast_reload", "extended_ammo", "pas_fast_ads", "pas_run_and_gun", "pas_fast_swap", "hcog" ] 

	// smg
	file.carePackageWeaponMods["mp_weapon_car"] <- [ "pas_fast_reload", "extended_ammo", "pas_fast_ads", "pas_run_and_gun", "pas_fast_swap", "holosight" ] 
	file.carePackageWeaponMods["mp_weapon_alternator_smg"] <- [ "pas_fast_reload", "extended_ammo", "pas_fast_ads", "pas_run_and_gun", "pas_fast_swap", "holosight" ] 
	file.carePackageWeaponMods["mp_weapon_hemlok_smg"] <- [ "pas_fast_reload", "extended_ammo", "pas_fast_ads", "pas_run_and_gun", "pas_fast_swap", "holosight" ] 
	file.carePackageWeaponMods["mp_weapon_r97"] <- [ "pas_fast_reload", "extended_ammo", "pas_fast_ads", "pas_run_and_gun", "pas_fast_swap", "holosight" ] 

	// launcher
	file.carePackageWeaponMods["mp_weapon_epg"] <- [ "pas_fast_reload", "extended_ammo", "pas_fast_swap", "pas_run_and_gun" ] 
	file.carePackageWeaponMods["mp_weapon_softball"] <- [ "pas_fast_reload", "extended_ammo", "pas_fast_swap", "pas_run_and_gun" ] 
	file.carePackageWeaponMods["mp_weapon_smr"] <- [ "pas_fast_reload", "extended_ammo", "pas_fast_swap", "pas_run_and_gun", "burn_mod_smr" ] 
	file.carePackageWeaponMods["mp_weapon_pulse_lmg"] <- [ "pas_fast_reload", "extended_ammo", "pas_fast_swap", "pas_run_and_gun" ] 

	// lmg
	file.carePackageWeaponMods["mp_weapon_lmg"] <- [ "pas_fast_reload", "extended_ammo", "pas_fast_ads", "pas_run_and_gun", "redline_sight" ] 
	file.carePackageWeaponMods["mp_weapon_lstar"] <- [ "pas_fast_reload", "extended_ammo", "pas_fast_swap", "pas_run_and_gun", "redline_sight", "reloadanimtest" ] // will have a halfed reload animation! 
	file.carePackageWeaponMods["mp_weapon_esaw"] <- [ "pas_fast_reload", "extended_ammo", "pas_fast_swap", "pas_run_and_gun", "redline_sight" ] 
}

void function InitDefaultNPCWeapons()
{
	// pilot weapons
	array<string> pilotMainWeapons =
	[ // try to make this all anti-titans? or grenadiers idk
		"mp_weapon_rspn101_og", 
		"mp_weapon_r97", 
		"mp_weapon_car",
		"mp_weapon_alternator_smg",
		"mp_weapon_vinson" ,
		"mp_weapon_epg",
		//"mp_weapon_smr",
		//"mp_weapon_defender",
		//"mp_weapon_mgl",
		//"mp_weapon_rocket_launcher"
	]
	array<string> pilotAntiTitanWeapons = 
	[ 
		//"mp_weapon_defender", 
		"mp_weapon_rocket_launcher",
		"mp_weapon_mgl",
		"mp_weapon_arc_launcher", // modded, they can now be used by npcs
		"mp_weapon_defender"
	]

	// grunt weapons
	array<string> gruntMainWeapons =
	[
		"mp_weapon_r97", 
		"mp_weapon_rspn101", 
		"mp_weapon_lmg", 
		"mp_weapon_dmr"
	]

	// spectre weapons
	array<string> spectreMainWeapons =
	[
		"mp_weapon_mastiff", 
		"mp_weapon_doubletake", 
		"mp_weapon_hemlok_smg"
	]

	// stalker weapons
	array<string> stalkerMainWeapons =
	[
		"mp_weapon_mastiff", 
		"mp_weapon_hemlok_smg",
		"mp_weapon_lstar"
	]

	// pilot
	file.npcMainWeaponsTable[ "npc_pilot_elite" ] <- pilotMainWeapons
	file.npcAntiTitanWeaponsTable[ "npc_pilot_elite" ] <- pilotAntiTitanWeapons
	// grunt
	file.npcMainWeaponsTable[ "npc_soldier" ] <- gruntMainWeapons
	// spectre
	file.npcMainWeaponsTable[ "npc_spectre" ] <- spectreMainWeapons
	// stalker
	file.npcMainWeaponsTable[ "npc_stalker" ] <- stalkerMainWeapons
}

void function InitDefaultTitanList()
{
	// ion
	ExtraSpawner_RegisterToTitanSpawnList
	(
		"ion",											// spawn name. unique
		"titan_atlas_stickybomb",						// setFile
		"npc_titan_auto_atlas_stickybomb",				// aiSet
		"execution_ion",								// executionRef, npc ion can't use prime executions
		// after being embarked by npcs
		"npc_titan_atlas_stickybomb",					// embarkedAiSet
		"behavior_titan",								// embarkedBehavior
		"#NPC_TITAN_ATLAS_STICKYBOMB",					// embarkedTitle
		null, 											// no loadout function
		1,												// imc team skinIndex
		3												// mlt team skinIndex
	)

	// scorch
	ExtraSpawner_RegisterToTitanSpawnList
	(
		"scorch",										// spawn name. unique
		"titan_ogre_meteor",							// setFile
		"npc_titan_auto_ogre_meteor",					// aiSet
		"execution_scorch",								// executionRef, prime execution leave for modded titans
		// after being embarked by npcs
		"npc_titan_ogre_meteor",						// embarkedAiSet
		"behavior_titan_ogre_meteor",					// embarkedBehavior
		"#NPC_TITAN_OGRE_METEOR",						// embarkedTitle
		null, 											// no loadout function
		1,												// imc team skinIndex
		9												// mlt team skinIndex
	)

	// northstar
	ExtraSpawner_RegisterToTitanSpawnList
	(
		"northstar",									// spawn name. unique
		"titan_stryder_sniper",							// setFile
		"npc_titan_auto_stryder_sniper",				// aiSet
		"execution_northstar",							// executionRef, prime execution leave for modded titans
		// after being embarked by npcs
		"npc_titan_stryder_sniper",						// embarkedAiSet
		"behavior_titan_sniper",						// embarkedBehavior
		"#NPC_TITAN_STRYDER_SNIPER",					// embarkedTitle
		null, 											// no loadout function
		1,												// imc team skinIndex
		3												// mlt team skinIndex
	)

	// ronin
	ExtraSpawner_RegisterToTitanSpawnList
	(
		"ronin",										// spawn name. unique
		"titan_stryder_leadwall",						// setFile
		"npc_titan_auto_stryder_leadwall",				// aiSet
		"execution_ronin",								// executionRef, prime execution leave for modded titans
		// after being embarked by npcs
		"npc_titan_stryder_leadwall",					// embarkedAiSet
		"behavior_titan_shotgun",						// embarkedBehavior
		"#NPC_TITAN_STRYDER_LEADWALL",					// embarkedTitle
		null, 											// no loadout function
		-1,												// imc team skinIndex, -1 means don't reset
		3												// mlt team skinIndex
	)

	// tone
	ExtraSpawner_RegisterToTitanSpawnList
	(
		"tone",											// spawn name. unique
		"titan_atlas_tracker",							// setFile
		"npc_titan_auto_atlas_tracker",					// aiSet
		"execution_tone",								// executionRef, prime execution leave for modded titans
		// after being embarked by npcs
		"npc_titan_atlas_tracker",						// embarkedAiSet
		"behavior_titan_long_range",					// embarkedBehavior
		"#NPC_TITAN_ATLAS_TRACKER",						// embarkedTitle
		null, 											// no loadout function
		-1,												// imc team skinIndex, -1 means don't reset
		1												// mlt team skinIndex
	)

	// legion
	ExtraSpawner_RegisterToTitanSpawnList
	(
		"legion",										// spawn name. unique
		"titan_ogre_minigun",							// setFile
		"npc_titan_auto_ogre_minigun",					// aiSet
		"execution_legion",								// executionRef, prime execution leave for modded titans
		// after being embarked by npcs
		"npc_titan_ogre_minigun",						// embarkedAiSet
		"behavior_titan_ogre_minigun",					// embarkedBehavior
		"#NPC_TITAN_OGRE_MINIGUN",						// embarkedTitle
		null, 											// no loadout function
		1,												// imc team skinIndex
		3												// mlt team skinIndex
	)

	// monarch
	ExtraSpawner_RegisterToTitanSpawnList
	(
		"monarch",										// spawn name. unique
		"titan_atlas_vanguard",							// setFile
		"npc_titan_auto_atlas_vanguard",				// aiSet
		"execution_vanguard",							// executionRef, kit execution leave for modded titans
		// after being embarked by npcs
		"npc_titan_atlas_vanguard",						// embarkedAiSet
		"behavior_titan",								// embarkedBehavior
		"#NPC_TITAN_ATLAS_VANGUARD",					// embarkedTitle
		null, 											// no loadout function
		-1,												// imc team skinIndex, -1 means don't reset
		3												// mlt team skinIndex
	)

	// brute
	ExtraSpawner_RegisterToTitanSpawnList
	(
		"brute",										// spawn name. unique
		"titan_stryder_sniper",							// setFile
		"npc_titan_auto_stryder_sniper",				// aiSet, rocketeer stryder don't have a autotitan aiSet
		"execution_northstar_prime",					// executionRef, this one don't require weapons
		// after being embarked by npcs
		"npc_titan_stryder_rocketeer",					// embarkedAiSet
		"behavior_titan_rocketeer",						// embarkedBehavior
		"#NPC_TITAN_STRYDER_ROCKET",					// embarkedTitle
		NPCBruteLoadout,								// loadout function
		6,												// imc team skinIndex
		8												// mlt team skinIndex
	)

	// bison
	ExtraSpawner_RegisterToTitanSpawnList
	(
		"bison",										// spawn name. unique
		"titan_ogre_meteor",							// setFile
		"npc_titan_auto_ogre_scorch_prime",				// aiSet
		"execution_scorch_prime",						// executionRef, this one don't require weapons
		// after being embarked by npcs
		"npc_titan_ogre_fighter",						// embarkedAiSet, core aiset handled by titan core
		"behavior_titan_melee",							// embarkedBehavior, core behavior handled by titan core
		"#NPC_TITAN_OGRE_FIGHTER",						// embarkedTitle
		NPCBisonLoadout
	)

	/*
	// modded weapon titans
	// brute4
	ExtraSpawner_RegisterToTitanSpawnList
	(
		"brute4_modded",								// spawn name. unique
		"titan_stryder_sniper",							// setFile
		"npc_titan_auto_stryder_northstar_prime",		// aiSet
		"execution_northstar_prime",					// executionRef, this one don't require weapons
		// after being embarked by npcs
		"npc_titan_stryder_rocketeer",					// embarkedAiSet
		"behavior_titan_shotgun",						// embarkedBehavior, hover ability is bind together with "behavior_titan_rocketeer", use shotgun instead
		"#NPC_TITAN_AUTO_ATLAS_ROCKETEER",				// embarkedTitle
		NPCBrute4Loadout
	)

	// archon, WIP. sometimes crashes client when shock ball hits player, also mostly can't fire arc cannon
	ExtraSpawner_RegisterToTitanSpawnList
	(
		"archon_modded",								// spawn name. unique
		"titan_atlas_stickybomb",						// setFile
		"npc_titan_auto_atlas_ion_prime",				// aiSet
		"execution_ion_prime",							// executionRef, fixed npc ion using prime executions, but the chest laser will shot from behind!
		// after being embarked by npcs
		"npc_titan_atlas_stickybomb",					// embarkedAiSet
		"behavior_titan",								// embarkedBehavior
		"#NPC_TITAN_AUTO_STRYDER_ARC",					// embarkedTitle
		NPCArchonLoadout
	)
	*/
}
//

// modded titan loadout functions
void function NPCBruteLoadout( entity titan )
{
	TakeAllWeapons( titan )
	//Weapon
	titan.GiveWeapon( "mp_titanweapon_rocketeer_rocketstream", ["brute_rocket"] )
	//Defence
	titan.GiveOffhandWeapon( "mp_titanweapon_vortex_shield", OFFHAND_SPECIAL, ["slow_recovery_vortex"] )
	// Utility
	titan.GiveOffhandWeapon( "mp_titanability_hover", OFFHAND_ANTIRODEO )
	//Offence
	//titan.GiveOffhandWeapon( "mp_titanweapon_shoulder_rockets", OFFHAND_ORDNANCE )
	titan.GiveOffhandWeapon( "mp_titanweapon_salvo_rockets", OFFHAND_ORDNANCE, ["brute4_grenade_launcher"] )
	//Titan Core
	titan.GiveOffhandWeapon( "mp_titancore_flight_core", OFFHAND_EQUIPMENT )
	//Melee
	titan.GiveOffhandWeapon( "melee_titan_punch_northstar", OFFHAND_MELEE )

	//titan.SetBehaviorSelector( "behavior_titan_rocketeer" ) // default behavior, being set after embarking
	titan.SetTitle( "#NPC_TITAN_AUTO_STRYDER_ROCKET" )

	entity soul = titan.GetTitanSoul()
	if ( IsValid( soul ) )
		MeleeSyncedTitan_SetSoulShouldReplaceLoadoutOnExecution( soul, true ) // required for executions behave nicely
}

void function NPCBisonLoadout( entity titan )
{
	TakeAllWeapons( titan )
	//Weapon, npc bison is not smart enough, give them a main weapon
	titan.GiveWeapon( "mp_titanweapon_triplethreat", ["bison_triplethreat"] )
	//Defence
	titan.GiveOffhandWeapon( "mp_titanability_particle_wall", OFFHAND_SPECIAL, ["brute4_bubble_shield", "molting_dome", "bison_dome"] )
	//Tactical
	//titan.GiveOffhandWeapon( "mp_titanability_laser_trip", OFFHAND_ANTIRODEO )
	titan.GiveOffhandWeapon( "mp_titanability_tether_trap", OFFHAND_ANTIRODEO )
	//Offence
	//titan.GiveOffhandWeapon( "mp_titanweapon_dumbfire_rockets", OFFHAND_ORDNANCE, ["pas_northstar_cluster", "fd_twin_cluster"] )
	titan.GiveOffhandWeapon( "mp_titanweapon_homing_rockets", OFFHAND_ORDNANCE, ["burn_mod_titan_homing_rockets", "fighter_rockets"] )
	//Titan Core
	titan.GiveOffhandWeapon( "mp_titancore_shift_core", OFFHAND_EQUIPMENT, ["berserker_core"] )
	//Melee
	titan.GiveOffhandWeapon( "melee_titan_punch_scorch", OFFHAND_MELEE )

	titan.SetTitle( "#NPC_TITAN_AUTO_OGRE_FIGHTER" )

	// execution_scorch_prime don't require weapons, no need to fix

	// camo for prime titans
	titan.SetSkin( TITAN_SKIN_INDEX_CAMO )
	titan.SetCamo( 31 ) // default is white. best camo for bison

	int team = titan.GetTeam()
	if ( team == TEAM_IMC )
		titan.SetCamo( 19 ) // shadow
	if ( team == TEAM_MILITIA )
		titan.SetCamo( 1 ) // forest
}

void function NPCBrute4Loadout( entity titan )
{
	TakeAllWeapons( titan )
	//Weapon
	titan.GiveWeapon( "mp_titanweapon_rocketeer_rocketstream", ["brute4_rocket_launcher"])
	//Defence
	titan.GiveOffhandWeapon( "mp_titanability_particle_wall", OFFHAND_SPECIAL, ["brute4_bubble_shield"] )
	//Tactical
	titan.GiveOffhandWeapon( "mp_titanability_rocketeer_ammo_swap", OFFHAND_ANTIRODEO )
	//Offence
	titan.GiveOffhandWeapon( "mp_titanweapon_salvo_rockets", OFFHAND_ORDNANCE, ["brute4_grenade_launcher"] )
	//Titan Core
	titan.GiveOffhandWeapon( "mp_titancore_flight_core", OFFHAND_EQUIPMENT, ["brute4_barrage_core"] )
	//Melee
	titan.GiveOffhandWeapon( "melee_titan_punch_northstar", OFFHAND_MELEE )

	titan.SetTitle( "#NPC_TITAN_AUTO_ATLAS_ROCKETEER" )

	// execution_northstar_prime don't require weapons, no need to fix

	// camo for prime titans
	int team = titan.GetTeam()
	if ( team == TEAM_IMC )
	{
		titan.SetSkin( TITAN_SKIN_INDEX_CAMO )
		titan.SetCamo( 19 ) // shadow
	}
	if ( team == TEAM_MILITIA )
	{
		titan.SetSkin( TITAN_SKIN_INDEX_CAMO )
		titan.SetCamo( 1 ) // forest
	}
}

void function NPCArchonLoadout( entity titan )
{
	TakeAllWeapons( titan )
	//Weapon
	titan.GiveWeapon ( "mp_titanweapon_sniper", ["archon_arc_cannon"])
	//Defence
	titan.GiveOffhandWeapon( "mp_titanweapon_vortex_shield", OFFHAND_SPECIAL, ["slow_recovery_vortex", "archon_shock_shield"] )
	//Tactical
	titan.GiveOffhandWeapon( "mp_titanability_laser_trip", OFFHAND_ANTIRODEO, ["archon_tesla_node"] )
	//Offence
	titan.GiveOffhandWeapon( "mp_titanweapon_stun_laser", OFFHAND_ORDNANCE, ["archon_charge_ball"] )
	//Titan Core
	titan.GiveOffhandWeapon( "mp_titancore_flame_wave", OFFHAND_EQUIPMENT, ["archon_storm_core"] )
	//Melee
	titan.GiveOffhandWeapon( "melee_titan_punch_ion", OFFHAND_MELEE )

	titan.SetTitle( "#NPC_TITAN_AUTO_STRYDER_ARC" )

	entity soul = titan.GetTitanSoul()
	if ( IsValid( soul ) )
		MeleeSyncedTitan_SetSoulShouldReplaceLoadoutOnExecution( soul, true ) // required for executions behave nicely

	// camo for prime titans
	int team = titan.GetTeam()
	if ( team == TEAM_IMC )
	{
		titan.SetSkin( TITAN_SKIN_INDEX_CAMO )
		titan.SetCamo( 19 ) // shadow
	}
	if ( team == TEAM_MILITIA )
	{
		titan.SetSkin( TITAN_SKIN_INDEX_CAMO )
		titan.SetCamo( 1 ) // forest
	}
}

// npc pilot score event, better be added by gamemodes
/*
void function KilledNPCPilotScoreEvent( entity pilot, var damageInfo )
{
	entity attacker = DamageInfo_GetAttacker( damageInfo )
	if( !IsValid( attacker ) )
		return
	if( !attacker.IsPlayer() )
		return
	AddPlayerScore( attacker, "EliminatePilot", pilot )
}
*/

void function InitDefaultBossTitanList()
{
	// slone
	ExtraSpawner_RegisterToBossTitanSpawnList
	(
		"slone",										// spawn name. unique
		"Slone",										// boss name
		"titan_atlas_stickybomb",						// setFile
		"npc_titan_atlas_stickybomb",					// aiSet
		"behavior_titan",								// titan behavior
		"execution_vanguard_kit",						// executionRef, npc ion can't use prime executions, just let them use battery thief
		"#BOSSNAME_SLONE",								// boss title
		"斯隆",											// pilot title. can't use localized string
		$"models/humans/pilots/pilot_heavy_roog_m.mdl",		// character model, use mp pilot model: holopilot female
		BossLoadout_Generic_NoModelForMP, 				// generic loadout function for bosses that has no pilot model for mp
		3,												// skin index, unsure
		1												// decal index
	)

	// kane
	ExtraSpawner_RegisterToBossTitanSpawnList
	(
		"kane",											// spawn name. unique
		"Kane",											// boss name
		"titan_ogre_meteor",							// setFile
		"npc_titan_ogre_meteor",						// aiSet
		"behavior_titan_ogre_meteor",					// titan behavior
		"execution_scorch_prime",						// executionRef
		"#BOSSNAME_KANE",								// boss title
		"肯恩",											// pilot title. can't use localized string
		$"models/humans/pilots/pilot_heavy_roog_m.mdl",		// character model, use mp pilot model: a-wall male
		BossLoadout_Generic_NoModelForMP, 				// generic loadout function for bosses that has no pilot model for mp
		3,												// skin index, unsure
		1												// decal index
	)

	// viper
	ExtraSpawner_RegisterToBossTitanSpawnList
	(
		"viper",										// spawn name. unique
		"Viper",										// boss name
		"titan_stryder_sniper",							// setFile
		"npc_titan_stryder_sniper",						// aiSet
		"behavior_titan_sniper",						// titan behavior
		"execution_northstar_prime",					// executionRef
		"#BOSSNAME_VIPER",								// boss title
		"毒蛇",											// pilot title. can't use localized string
		$"models/humans/pilots/pilot_medium_reaper_m.mdl",		// character model, use mp pilot model: pulse blade male
		BossLoadout_Generic_NoModelForMP, 				// generic loadout function for bosses that has no pilot model for mp
		1,												// skin index, unsure
		10												// decal index
	)

	// ash
	ExtraSpawner_RegisterToBossTitanSpawnList
	(
		"ash",											// spawn name. unique
		"Ash",											// boss name
		"titan_stryder_leadwall",						// setFile
		"npc_titan_stryder_leadwall",					// aiSet
		"behavior_titan_shotgun",						// titan behavior
		"execution_ronin_prime",						// executionRef
		"#BOSSNAME_ASH",								// boss title
		"艾許",											// pilot title. can't use localized string
		$"models/Humans/heroes/imc_hero_ash.mdl",		// character model
		BossLoadout_Generic_IMCBoss, 					// generic loadout function for imc bosses
		6,												// skin index
		10												// decal index
	)

	// richter
	ExtraSpawner_RegisterToBossTitanSpawnList
	(
		"richter",										// spawn name. unique
		"Richter",										// boss name
		"titan_atlas_tracker",							// setFile
		"npc_titan_atlas_tracker",						// aiSet
		"behavior_titan_long_range",					// titan behavior
		"execution_tone_prime",							// executionRef
		"#BOSSNAME_RICHTER",							// boss title
		"里赫特",										// pilot title. can't use localized string
		$"models/humans/pilots/pilot_heavy_drex_m.mdl",		// character model, use mp pilot model: cloak male
		BossLoadout_Generic_NoModelForMP, 				// generic loadout function for bosses that has no pilot model for mp
		5,												// skin index, unsure
		13												// decal index
	)

	// blisk
	ExtraSpawner_RegisterToBossTitanSpawnList
	(
		"blisk",										// spawn name. unique
		"Blisk",										// boss name
		"titan_ogre_minigun",							// setFile
		"npc_titan_ogre_minigun",						// aiSet
		"behavior_titan_ogre_minigun",					// titan behavior
		"execution_legion_prime",						// executionRef
		"#BOSSNAME_BLISK",								// boss title
		"布里斯克",										// pilot title. can't use localized string
		$"models/Humans/heroes/imc_hero_blisk.mdl",		// character model
		BossLoadout_Generic_IMCBoss, 					// generic loadout function for imc bosses
		8,												// skin index, unsure
		12												// decal index
	)

	// jack
	ExtraSpawner_RegisterToBossTitanSpawnList
	(
		"jack",											// spawn name. unique
		"",												// boss name. leave empty if this is not a valid boss titan
		"titan_buddy",									// setFile
		"npc_titan_buddy",								// aiSet
		"behavior_titan",								// titan behavior
		"execution_bt",									// executionRef
		"#NPC_BT_NAME",									// boss title
		"傑克庫柏",										// pilot title. can't use localized string
		$"models/humans/heroes/mlt_hero_jack.mdl",		// character model
		BossLoadout_Jack, 								// loadout function
		-1,												// skin index, -1 means don't reset
		-1												// decal index, -1 means don't reset
	)

	// sarah
	ExtraSpawner_RegisterToBossTitanSpawnList
	(
		"sarah",										// spawn name. unique
		"",												// boss name. leave empty if this is not a valid boss titan
		"titan_buddy",									// setFile
		"npc_titan_buddy",								// aiSet
		"behavior_titan",								// titan behavior
		"execution_bt",									// executionRef
		"#FACTION_LEADER_NAME_SARAH",					// boss title
		"莎拉",											// pilot title. can't use localized string
		$"models/humans/heroes/mlt_hero_sarah.mdl",		// character model
		BossLoadout_Sarah, 								// loadout function
		2,												// skin index
		0												// decal index
	)

	/*
	// sarah, monarch variant
	ExtraSpawner_RegisterToBossTitanSpawnList
	(
		"sarah_monarch",								// spawn name. unique
		"",												// boss name. leave empty if this is not a valid boss titan
		"titan_atlas_vanguard",							// setFile
		"npc_titan_atlas_vanguard_boss_fd",				// aiSet
		"behavior_titan",								// titan behavior
		"execution_vanguard_kit",						// executionRef
		"#FACTION_LEADER_NAME_SARAH",					// boss title
		"莎拉",											// pilot title. can't use localized string
		$"models/humans/heroes/mlt_hero_sarah.mdl",		// character model
		BossLoadout_SarahMonarch, 						// loadout function
		-1,												// skin index, -1 means don't reset
		-1												// decal index, -1 means don't reset
	)
	*/
}
//

// generic loadout function for bosses that has no pilot model for mp
void function BossLoadout_Generic_NoModelForMP( entity titan )
{
	entity soul = titan.GetTitanSoul()
	if ( IsValid( soul ) )
	{
		// disable their ejecting, so players won't easily notice that they have no proper model
		TitanHealth_SetSoulNPCPilotEjectDelay( soul, -1 ) // -1 means never eject
	}

	// nuke. imc titans do nuke
	SetupNPCPilotEmbarkedTitanNuke( titan )
}

// generic loadout function for imc bosses
void function BossLoadout_Generic_IMCBoss( entity titan )
{
	// nuke. imc titans do nuke
	SetupNPCPilotEmbarkedTitanNuke( titan )
}

void function BossLoadout_Jack( entity titan )
{
	// bt require a "squad" to spawn
	string squadName = MakeSquadName( titan.GetTeam(), UniqueString( "ZiplineTable" ) )
	SetSquad( titan, squadName )

	// re-assign weapons
	titan.TakeWeaponNow( "mp_titanweapon_xo16_shorty" ) // don't use a one-shot killing xo16!
	titan.GiveWeapon( "mp_titanweapon_xo16_vanguard", ["arc_rounds"] ) // use the arc-rounds monarch xo16
	titan.GetOffhandWeapon( OFFHAND_SPECIAL ).AddMod( "slow_recovery_vortex" ) // fix weapon mod
	titan.GetOffhandWeapon( OFFHAND_ORDNANCE ).AddMod( "upgradeCore_MissileRack_Vanguard" ) // fix mod: lock on heavy armor target only
	titan.GetOffhandWeapon( OFFHAND_EQUIPMENT ).AddMod( "npc_bt_balance" ) // balance core ability

	// game behavior settings
	entity soul = titan.GetTitanSoul()
	if ( IsValid( soul ) )
	{
		MeleeSyncedTitan_SetSoulCanBeExecuted( soul, false ) // cannot execute BT, they don't have enough animations
		Rodeo_SetTitanRodeoSequenceEnabled( titan, false ) // bt don't have battery on hatch, don't allow removing
	}
}

void function BossLoadout_Sarah( entity titan )
{
	// bt require a "squad" to spawn
	string squadName = MakeSquadName( titan.GetTeam(), UniqueString( "ZiplineTable" ) )
	SetSquad( titan, squadName )

	// re-assign weapons
	titan.TakeWeaponNow( "mp_titanweapon_xo16_shorty" ) // don't use a one-shot killing xo16!
	titan.GiveWeapon( "mp_titanweapon_xo16_vanguard", ["battle_rifle", "battle_rifle_icon", "fd_vanguard_utility_2"] )
	titan.TakeOffhandWeapon( OFFHAND_ORDNANCE )
	titan.GiveOffhandWeapon( "mp_titanweapon_salvo_rockets", OFFHAND_ORDNANCE, ["missile_racks"] )
	titan.TakeOffhandWeapon( OFFHAND_SPECIAL )
	titan.GiveOffhandWeapon( "mp_titanweapon_heat_shield", OFFHAND_SPECIAL )
	titan.TakeOffhandWeapon( OFFHAND_ANTIRODEO )
	titan.GetOffhandWeapon( OFFHAND_EQUIPMENT ).AddMod( "npc_bt_balance" ) // balance core ability

	// game behavior settings
	entity soul = titan.GetTitanSoul()
	if ( IsValid( soul ) )
	{
		MeleeSyncedTitan_SetSoulCanBeExecuted( soul, false ) // cannot execute BT, they don't have enough animations
		Rodeo_SetTitanRodeoSequenceEnabled( titan, false ) // bt don't have battery on hatch, don't allow removing
	}
}

void function BossLoadout_SarahMonarch( entity titan )
{
	// re-assign weapons
	titan.GetMainWeapons()[0].SetMods( ["battle_rifle", "battle_rifle_icon", "fd_vanguard_utility_2"] )
	titan.TakeOffhandWeapon( OFFHAND_ORDNANCE )
	//titan.GiveOffhandWeapon( "mp_titanweapon_shoulder_rockets", OFFHAND_ORDNANCE, ["upgradeCore_MissileRack_Vanguard"] )
	titan.GiveOffhandWeapon( "mp_titanweapon_salvo_rockets", OFFHAND_ORDNANCE, ["missile_racks"] )
	titan.TakeOffhandWeapon( OFFHAND_SPECIAL )
	//titan.GiveOffhandWeapon( "mp_titanweapon_stun_laser", OFFHAND_SPECIAL, ["energy_field_energy_transfer"] )
	titan.GiveOffhandWeapon( "mp_titanweapon_heat_shield", OFFHAND_SPECIAL )
	titan.TakeOffhandWeapon( OFFHAND_ANTIRODEO )
	titan.GiveOffhandWeapon( "mp_titanability_smoke", OFFHAND_ANTIRODEO )
	titan.TakeOffhandWeapon( OFFHAND_EQUIPMENT )
	titan.GiveOffhandWeapon( "mp_titancore_amp_core", OFFHAND_EQUIPMENT, ["npc_bt_balance"] )
}

void function InitDefaultNPCHandlerFunctions()
{
	file.squadHandlerFunc = ExtraSpawner_SquadHandler
	file.npcHandlerFuncs[ "npc_pilot_elite" ] <- ExtraSpawner_PilotHandler
	file.npcHandlerFuncs[ "npc_titan" ] <- ExtraSpawner_TitanHandler
	file.npcHandlerFuncs[ "npc_super_spectre" ] <- ExtraSpawner_ReaperHandler
}

void functionref( entity ) function GetNPCHandlerForClass( string className )
{
	if ( !( className in file.npcHandlerFuncs ) )
		return null
	return file.npcHandlerFuncs[ className ]
}

void function ExtraSpawner_SetNPCWeapons( string npcClass, array<string> weapons )
{
	if ( !( npcClass in file.npcMainWeaponsTable ) )
		file.npcMainWeaponsTable[ npcClass ] <- []
	file.npcMainWeaponsTable[ npcClass ] = weapons
}

void function ExtraSpawner_SetNPCAntiTitanWeapons( string npcClass, array<string> weapons )
{
	if ( !( npcClass in file.npcAntiTitanWeaponsTable ) )
		file.npcAntiTitanWeaponsTable[ npcClass ] <- []
	file.npcAntiTitanWeaponsTable[ npcClass ] = weapons
}

void function ExtraSpawner_SetNPCGrenadeWeapons( string npcClass, array<string> weapons )
{
	if ( !( npcClass in file.npcGrenadeWeaponsTable ) )
		file.npcGrenadeWeaponsTable[ npcClass ] <- []
	file.npcGrenadeWeaponsTable[ npcClass ] = weapons
}

void function ExtraSpawner_SetNPCExtraWeaponMods( string npcClass, array<string> mods )
{
	if ( !( npcClass in file.npcExtraWeaponModsTable ) )
		file.npcExtraWeaponModsTable[ npcClass ] <- []
	file.npcExtraWeaponModsTable[ npcClass ] = mods
}

void function ExtraSpawner_SetCarePackageWeapons( array<string> weapons )
{
	file.carePackageWeapons = weapons
}

// this can only set a single weapon's mod
void function ExtraSpawner_SetCarePackageWeaponMods( string weaponName, array<string> weaponMods )
{
	if ( !( weaponName in file.carePackageWeaponMods ) )
		file.carePackageWeaponMods[weaponName] <- weaponMods
	else
		file.carePackageWeaponMods[weaponName] = weaponMods
}

// this will reset the whole table
void function ExtraSpawner_SetCarePackageWeaponModsMultiple( table< string, array<string> > weaponModsTable )
{
	file.carePackageWeaponMods = weaponModsTable
}

void function ExtraSpawner_RegisterToTitanSpawnList( string spawnName, string setFile, string aiSet, string executionRef = "", string embarkedAiSet = "", string embarkedBehavior = "", string embarkedTitle = "", void functionref( entity ) loadoutFunction = null, int imcSkinIndex = -1, int mltSkinIndex = -1 )
{
	// spawn name needs to be unique
	if ( spawnName in file.titanSpawnList )
	{
		print( "[EXTRA SPAWNER] Titan with name \"" + spawnName + "\" has already been registered!" )
		return
	}

	TitanSpawnStruct newStruct
	newStruct.setFile = setFile
	newStruct.aiSet = aiSet
	newStruct.executionRef = executionRef // funny with MeleeSyncedNPC
	// after being embarked by npcs
	newStruct.embarkedAiSet = embarkedAiSet
	newStruct.embarkedBehavior = embarkedBehavior
	newStruct.embarkedTitle = embarkedTitle
	// loadout
	newStruct.loadoutFunction = loadoutFunction
	// skin
	newStruct.imcSkinIndex = imcSkinIndex
	newStruct.mltSkinIndex = mltSkinIndex

	file.titanSpawnList[ spawnName ] <- newStruct
	print( "[EXTRA SPAWNER] Registered titan spawn: " + spawnName )
}

void function ExtraSpawner_RegisterToBossTitanSpawnList( string spawnName, string bossName, string setFile, string aiSet, string behavior = "", string executionRef = "", string bossTitle = "", string pilotTitle = "", asset characterModel = $"", void functionref( entity ) loadoutFunction = null, int skinIndex = -1, int decalIndex = -1 )
{
	// spawn name needs to be unique
	if ( spawnName in file.bossTitanSpawnList )
	{
		print( "[EXTRA SPAWNER] Boss titan with name \"" + spawnName + "\" has already been registered!" )
		return
	}

	BossTitanSpawnStruct newStruct
	newStruct.bossName = bossName
	newStruct.setFile = setFile
	newStruct.aiSet = aiSet
	newStruct.behavior = behavior
	newStruct.executionRef = executionRef // funny with MeleeSyncedNPC
	newStruct.bossTitle = bossTitle
	newStruct.pilotTitle = pilotTitle
	newStruct.characterModel = characterModel
	// loadout
	newStruct.loadoutFunction = loadoutFunction
	// skin
	newStruct.skinIndex = skinIndex
	newStruct.decalIndex = decalIndex

	file.bossTitanSpawnList[ spawnName ] <- newStruct
	print( "[EXTRA SPAWNER] Registered Boss titan spawn: " + spawnName )
}

void function SetupNPCPilotEmbarkedTitanNuke( entity titan )
{
	NPC_SetNuclearPayload( titan )

	entity soul = titan.GetTitanSoul()
	if ( IsValid( soul ) )
	{
		// modified functions in sh_titan.gnut
		// prevent titan get destroyed before nuke ends and dealing damage to friendly players
		TitanEject_SetSoulUseNPCPilotAsNukeAttacker( soul, true )
		// make damage same as player's titan does, with longer explosion duration
		TitanEject_SetSoulNukeExplosionDamageOverride( 
			soul, 			// current soul
			10, 			// explosion count
			1.5, 			// explosion duration
			75, 			// damage
			2500, 			// damage heavy armor
			350, 			// inner radius
			600, 			// outer radius
			SF_ENVEXPLOSION_MASK_BRUSHONLY,		// explosion flags
			0,				// explosion force
			DF_RAGDOLL | DF_EXPLOSION			// script damage flags
		)
	}
}

void function ExtraSpawner_SetSquadHandlerFunc( void functionref( array<entity> ) handler )
{
	file.squadHandlerFunc = handler
}

void function ExtraSpawner_SetNPCHandlerFunc( string npcClass, void functionref( entity ) handler )
{
	if ( !( npcClass in file.npcHandlerFuncs ) )
		file.npcHandlerFuncs[ npcClass ] <- null
	file.npcHandlerFuncs[ npcClass ] = handler
}

// can't stop squad handler
void function ExtraSpawner_StopDefaultHandler( entity npc )
{
	npc.Signal( "StopDefaultHandler" )
}

//------------------------------------------------------

bool function CC_SpawnPilotAndTitan( entity player, array<string> args )
{   
	if( !BATTERY_SPAWNERS.contains( player.GetUID() ) )
		return false

    Point dropPoint = GetTitanReplacementPoint( player )
	thread ExtraSpawner_SpawnPilotCanEmbark( dropPoint.origin, dropPoint.angles, GetPlayerAISpawnTeam( player, args ) )
	return true
}

bool function CC_SpawnReaperCanLaunchTicks( entity player, array<string> args )
{
	if( !BATTERY_SPAWNERS.contains( player.GetUID() ) )
		return false

	Point dropPoint = GetTitanReplacementPoint( player )
    thread ExtraSpawner_SpawnReaperCanLaunchTicks( dropPoint.origin, dropPoint.angles, GetPlayerAISpawnTeam( player, args ) )
    return true
}

bool function CC_SpawnGunShip( entity player, array<string> args )
{
	if( !BATTERY_SPAWNERS.contains( player.GetUID() ) )
		return false

	Point dropPoint = GetTitanReplacementPoint( player )
    thread ExtraSpawner_SpawnGunShip( dropPoint.origin + < 0,0,100 >, dropPoint.angles, GetPlayerAISpawnTeam( player, args ) )
    return true
}

bool function CC_SpawnAssassinPilot( entity player, array<string> args )
{
	if( !BATTERY_SPAWNERS.contains( player.GetUID() ) )
		return false

	vector pos = GetPlayerCrosshairOrigin( player )
	vector playerAngs = player.EyeAngles()
	vector rot = < 0, ClampAngle( playerAngs.y - 180 ), 0 >
	entity pilot = CreateNPC( "npc_pilot_elite", GetPlayerAISpawnTeam( player, args ), pos, rot )
	SetSpawnOption_AISettings( pilot, "npc_pilot_elite_assassin" )
	pilot.s.petTitan <- null // initializing
	pilot.s.nextTitanRespawnAvailable <- null

	// many things below should have a reference in _ai_pilots.gnut, for npc pilots ejecting
	asset modelAsset = NPC_PILOT_ALLOWED_MODELS[ RandomInt(NPC_PILOT_ALLOWED_MODELS.len()) ]
	pilot.SetValueForModelKey( modelAsset )
	pilot.SetModel( modelAsset )//

	file.npcSpawnFromExtraSpawner[ pilot ] <- true
	DispatchSpawn( pilot ) // don't delayed dispatchSpawn()
	pilot.SetModel( modelAsset )
	ExtraSpawner_SetUpNPCPilot( pilot )

	return true
}

bool function CC_SpawnSpecialistGrunt( entity player, array<string> args )
{
	if( !BATTERY_SPAWNERS.contains( player.GetUID() ) )
		return false

	vector pos = GetPlayerCrosshairOrigin( player )
	vector playerAngs = player.EyeAngles()
	vector rot = < 0, ClampAngle( playerAngs.y - 180 ), 0 >
	entity grunt = CreateNPC( "npc_soldier", GetPlayerAISpawnTeam( player, args ), pos, rot )
	SetSpawnOption_AISettings( grunt, "npc_soldier_pve_specialist" )

	file.npcSpawnFromExtraSpawner[ grunt ] <- true
	DispatchSpawn( grunt ) // don't delayed dispatchSpawn()

	grunt.SetModel( $"models/robots/spectre/imc_spectre.mdl" )

	return true
}

bool function CC_SpawnPilotElite( entity player, array<string> args )
{   
	if( !BATTERY_SPAWNERS.contains( player.GetUID() ) )
		return false
	
	vector pos = GetPlayerCrosshairOrigin( player )
	vector playerAngs = player.EyeAngles()
	vector rot = < 0, ClampAngle( playerAngs.y - 180 ), 0 >
   
	entity pilot = ExtraSpawner_SpawnPilotElite( pos, rot, GetPlayerAISpawnTeam( player, args ) )
    TakeAllWeapons( pilot )
	//pilot.GiveWeapon( "mp_titanweapon_sniper", ["archon_arc_cannon"] )
	//pilot.GiveWeapon( "mp_weapon_defender" )
	pilot.GiveWeapon( "mp_weapon_pulse_lmg" )
	//pilot.GiveWeapon( "mp_weapon_hemlok" )
	return true
}

bool function CC_SpawnBossTitanWithIntro( entity player, array<string> args )
{
	if ( !GetConVarBool( "sv_cheats" ) )
	{
		if( !BATTERY_SPAWNERS.contains( player.GetUID() ) )
			return false
	}

	if ( args.len() == 0 )
		return true

	vector pos = GetPlayerCrosshairOrigin( player )
	vector playerAngs = player.EyeAngles()
	vector rot = < 0, ClampAngle( playerAngs.y - 180 ), 0 >
	int team = TEAM_BOTH

	string bossType = args[0].tolower()
	ExtraSpawner_SpawnBossTitan( pos, rot, team, bossType, TITAN_MERC )

	return true
}

bool function CC_SpawnTestPistolGrunt( entity player, array<string> args )
{
	if( !BATTERY_SPAWNERS.contains( player.GetUID() ) )
		return false

	vector pos = GetPlayerCrosshairOrigin( player )
	vector playerAngs = player.EyeAngles()
	vector rot = < 0, ClampAngle( playerAngs.y - 180 ), 0 >
	entity grunt = CreateNPC( "npc_soldier", GetPlayerAISpawnTeam( player, args ), pos, rot )
	grunt.SetBehaviorSelector( "behavior_sp_soldier" ) // they'll switch to pistol if needed
	//SetSpawnOption_Weapon( grunt, "mp_weapon_smart_pistol" )
	//SetSpawnOption_Weapon( grunt, "mp_weapon_wingman" )
	//SetSpawnOption_Weapon( grunt, "mp_weapon_autopistol" )
	//SetSpawnOption_Weapon( grunt, "mp_weapon_semipistol" )
	//SetSpawnOption_Weapon( grunt, "mp_weapon_alternator_smg" )
	//SetSpawnOption_Weapon( grunt, "mp_weapon_wingman_n" )
	//SetSpawnOption_Weapon( grunt, "mp_weapon_shotgun_pistol" )
	SetSpawnOption_Weapon( grunt, "mp_weapon_shotgun_doublebarrel_tfo" )

	file.npcSpawnFromExtraSpawner[ grunt ] <- true
	DispatchSpawn( grunt ) // don't delayed dispatchSpawn()

	//grunt.kv.WeaponProficiency = eWeaponProficiency.PERFECT // they can shoot very nice
	grunt.GetMainWeapons()[0].AddMod( "projectile_shotgun_npc" )

	//grunt.SetModel( $"models/robots/spectre/imc_spectre.mdl" )

	return true
}

// utility
int function GetPlayerAISpawnTeam( entity player, array<string> args )
{
	int team = TEAM_UNASSIGNED
	if( IsFFAGame() )
		team = TEAM_BOTH // so this ai won't have any teammates
    else
		team = GetOtherTeam( player.GetTeam() )

	if( args.len() > 0 )
	{
		if( args[0] == "sameteam" ) // spawn as teammate
			team = player.GetTeam()
	}

	return team
}

//------------------------------------------------------

// copied from cl_replacement_titan_hud.gnut
void function HotDrop_Spawnpoint( vector origin, int team, float impactTime, bool hasFriendlyWarning = false, int damageDef = -1 )
{
	array<entity> targetEffects = []
	vector surfaceNormal = < 0, 0, 1 >

	int index = GetParticleSystemIndex( $"P_ar_titan_droppoint" )

	if( hasFriendlyWarning || FriendlyFire_IsEnabled() ) // also warn friendly players, if we enabled friendly fire...
	{
		entity effectFriendly = StartParticleEffectInWorld_ReturnEntity( index, origin, surfaceNormal )
		SetTeam( effectFriendly, team )
		EffectSetControlPointVector( effectFriendly, 1, FRIENDLY_COLOR_FX )
		effectFriendly.kv.VisibilityFlags = ENTITY_VISIBLE_TO_FRIENDLY
		effectFriendly.DisableHibernation()
		targetEffects.append( effectFriendly )
	}

	entity effectEnemy = StartParticleEffectInWorld_ReturnEntity( index, origin, surfaceNormal )
	SetTeam( effectEnemy, team )
	EffectSetControlPointVector( effectEnemy, 1, ENEMY_COLOR_FX )
	effectEnemy.kv.VisibilityFlags = ENTITY_VISIBLE_TO_ENEMY
	effectEnemy.DisableHibernation()
	targetEffects.append( effectEnemy )

	// so enemy npcs will mostly avoid them
	entity damageAreaInfo
	if ( damageDef > -1 )
	{
		damageAreaInfo = CreateEntity( "info_target" )
		DispatchSpawn( damageAreaInfo )
		int dangerousTeam = FriendlyFire_IsEnabled() ? TEAM_BOTH : team // add friendlyfire support: if we enabled friendlyfire, this dangerous area will work for friendly npcs
		AI_CreateDangerousArea_DamageDef( damageDef, damageAreaInfo, dangerousTeam, true, true )
	}

	wait impactTime

	// clean up
	foreach( entity targetEffect in targetEffects )
	{
		if ( IsValid( targetEffect ) )
			EffectStop( targetEffect )
	}
	if ( IsValid( damageAreaInfo ) )
		damageAreaInfo.Destroy()
}

void function ExtraSpawner_ApplyNPCWeapons( entity npc, bool replaceAllWeapons = true, bool applyMods = true )
{
	string className = npc.GetClassName()

	array<string> mainWeapons
	array<string> antiTitanWeapons
	if ( className in file.npcMainWeaponsTable )
		mainWeapons = file.npcMainWeaponsTable[ className ]
	if ( className in file.npcAntiTitanWeaponsTable )
		antiTitanWeapons = file.npcAntiTitanWeaponsTable[ className ]

	if ( mainWeapons.len() == 0 && antiTitanWeapons.len() == 0 ) // no valid weapons
		return

	// take off existing main weapons, or sometimes they'll have a archer
	if ( replaceAllWeapons ) // only take all weapons if we're doing replacement.
	{
		foreach ( entity weapon in npc.GetMainWeapons() )
			npc.TakeWeaponNow( weapon.GetWeaponClassName() )
	}
	else // if we're not doing weapon replace, npc shouldn't take more than 3 weapons
	{
		if ( npc.GetMainWeapons().len() == 3 )
			return
	}

	// main weapon
	bool giveMainWeapon = mainWeapons.len() > 0
	if ( !replaceAllWeapons && npc.GetMainWeapons().len() >= 1 ) // npc already have a weapon and we disabled replace!
		giveMainWeapon = false // don't give main weapon again
	if ( giveMainWeapon )
	{
		string weaponName = mainWeapons[ RandomInt( mainWeapons.len() ) ]
		npc.GiveWeapon( weaponName )
		npc.SetActiveWeaponByName( weaponName )
	}
	// anti-titan
	bool giveAntiTitanWeapon = antiTitanWeapons.len() > 0
	if ( giveAntiTitanWeapon )
		npc.GiveWeapon( antiTitanWeapons[ RandomInt( antiTitanWeapons.len() ) ] )

	if ( applyMods )
		ExtraSpawner_ApplyNPCExtraWeaponMods( npc ) // add extra weapon mods

	// also make them use heavy armor weapon
	npc.SetEnemyChangeCallback( OnEnemyChanged_SwitchToHeavyArmorWeapon )
}

// grenade have to be given before DispatchSpawn()
void function ExtraSpawner_ApplyNPCGrenadeWeapon( entity npc )
{
	string className = npc.GetClassName()
	array<string> grenadeWeapons
	if ( className in file.npcGrenadeWeaponsTable )
		grenadeWeapons = file.npcGrenadeWeaponsTable[ className ]

	if ( grenadeWeapons.len() == 0 ) // no valid weapons
		return

	npc.kv.grenadeWeaponName = grenadeWeapons[ RandomInt( grenadeWeapons.len() ) ] // this mainly controlls which grenade npc will equip
	//print( "npc.kv.grenadeWeaponName: " + npc.kv.grenadeWeaponName )
}

void function ExtraSpawner_ApplyNPCExtraWeaponMods( entity npc )
{
	string className = npc.GetClassName()

	array<string> modsToApply
	if ( className in file.npcExtraWeaponModsTable )
		modsToApply = file.npcExtraWeaponModsTable[ className ]

	if ( modsToApply.len() == 0 ) // no valid mods
		return

	foreach ( entity weapon in npc.GetMainWeapons() )
	{
		array<string> validMods = GetWeaponMods_Global( weapon.GetWeaponClassName() )
		foreach ( string mod in modsToApply )
		{
			if ( !validMods.contains( mod ) ) // this weapon don't have such a mod!
				continue
			weapon.AddMod( mod )
		}
	}
}

// modified, since WT_ANTITITAN won't work in r2, hardcoded
const array<string> ANTI_TITAN_WEAPONS =
[
	"mp_weapon_defender",
	"mp_weapon_rocket_launcher",
	"mp_weapon_arc_launcher", // can't be used by npcs if vanilla
	"mp_weapon_mgl"
]

void function OnEnemyChanged_SwitchToHeavyArmorWeapon( entity guy )
{
	// every npc has this, but we'll save ones who have better proficiency
	if ( int( guy.kv.WeaponProficiency ) < eWeaponProficiency.VERYGOOD )
		SetProficiency( guy )

	entity enemy = guy.GetEnemy()
	if ( !IsAlive( enemy ) )
		return

	array<entity> weapons = guy.GetMainWeapons()
	// sniper grunt debug: don't know why they get a incorrect weapon cycle
	/* // fixed: adding active weaponName check in foreach()
	if ( guy.GetAISettingsName() == "npc_soldier_sidearm" )
	{
		foreach ( entity weapon in weapons )
			print( "weapon: " + weapon.GetWeaponClassName() )
	}
	*/

	// do we have a weapon to switch to?
	if ( weapons.len() < 2 )
		return

	entity activeWeapon = guy.GetActiveWeapon()
	string acitveWeaponName = ""
	if ( IsValid( activeWeapon ) )
		acitveWeaponName = activeWeapon.GetWeaponClassName()
	bool isHeavyArmorTarget = enemy.GetArmorType() == ARMOR_TYPE_HEAVY

	string weaponToChange = ""
	if( isHeavyArmorTarget )
	{
		// first try to find an appropriate weapon
		foreach ( entity weapon in weapons )
		{
			string className = weapon.GetWeaponClassName()
			bool isAntiTitan = ANTI_TITAN_WEAPONS.contains( className )
			if( isAntiTitan )
			{
				if ( acitveWeaponName == className ) // already holding this weapon
					return
				weaponToChange = className
			}
		}
	}
	else // light unit, switch off anti-titans
	{
		foreach ( entity weapon in weapons )
		{
			string className = weapon.GetWeaponClassName()
			bool isPrimary = !ANTI_TITAN_WEAPONS.contains( className )
			if( isPrimary )
			{
				if ( acitveWeaponName == className ) // already holding this weapon
					return
				weaponToChange = className
			}
		}
	}
 
	if ( weaponToChange == "" )
		return

	guy.SetActiveWeaponByName( weaponToChange )
	//print( "weaponToChange: " + weaponToChange )

	// grunt specific: do dialogue(vanilla missing this in grunt_chatter_mp.rpak)
	if ( IsGrunt( guy ) && isHeavyArmorTarget )
	{
		string dialogueType = "bc_switchingToAT"
		string dialoguePrefix = "diag_imc_grunt"
		int gruntVariants = 6 // 1~6
		int dialogueVariants = 2 // 1~2
		float debounce = 20.0
		// charge rifle specific
		if ( weaponToChange == "mp_weapon_defender" )
			dialogueType = "bc_usingChargeRifle"
		TryGruntDialogue( guy, dialogueType, dialoguePrefix, gruntVariants, dialogueVariants, debounce )
	}
}

// grunt dialogue is mostly a format of prefix + gruntNum + "_" + type + "_0" + dialogueNum
bool function TryGruntDialogue( entity guy, string dialogueType, string dialoguePrefix, int gruntVariants, int dialogueVariants, float debounce = 20.0 )
{
	string gruntNum = string( RandomInt( gruntVariants ) + 1 )
	string dialogueNum = string( RandomInt( dialogueVariants ) + 1 )
	string builtDialogue = dialoguePrefix + gruntNum + "_" + dialogueType + "_0" + dialogueNum

	return TryScriptedNPCDialogue( guy, builtDialogue, debounce )
}

// scripted npc dialogue, simply just emit a sound for npc
const float NPC_DISABLE_NEXT_DIALOGUE_DISTANCE = 2048 // npcs within this range will also be set in dialogue cooldown, so they mostly won't talk too much
bool function TryScriptedNPCDialogue( entity guy, string dialogue, float debounce )
{
	// init
	InitScriptedNPCDialogue( guy )

	// limit checks
	if ( Time() < file.npcDialogueNextAllowedTime[ guy ] )
		return false
	if ( file.npcLastDialogue[ guy ] != "" )
		StopSoundOnEntity( guy, file.npcLastDialogue[ guy ] )

	//print( "NPC " + string( guy ) + " is playing scripted dialogue: " + dialogue )

	EmitSoundOnEntity( guy, dialogue )
	//file.npcDialogueNextAllowedTime[ guy ] = Time() + debounce
	// apply debounce to all npcs around them, prevent being annoying!
	foreach ( entity otherGuy in GetNPCArray() )
	{
		if ( Distance2D( guy.GetOrigin(), otherGuy.GetOrigin() ) < NPC_DISABLE_NEXT_DIALOGUE_DISTANCE )
		{
			// init
			InitScriptedNPCDialogue( otherGuy )
			file.npcDialogueNextAllowedTime[ otherGuy ] = Time() + debounce
			//print( "Applying dialogue debounce to " + string( otherGuy ) + ". Debounce is: " + string( debounce ) )
		}
	}
	file.npcLastDialogue[ guy ] = dialogue

	thread TrackDialogueSpeakerDeath( guy, dialogue, debounce )
	return true
}

array<entity> function GetSquadMatesForNPC( entity guy )
{
	array<entity> squad
	string squadName = expect string( guy.kv.squadname )
	if ( squadName == "" )
		return squad

	squad = GetNPCArrayBySquad( squadName )
	squad.removebyvalue( guy ) // remove guy itself
	ArrayRemoveDead( squad ) // remove dead guys
	return squad
}

void function InitScriptedNPCDialogue( entity guy )
{
	if ( !( guy in file.npcDialogueNextAllowedTime ) )
		file.npcDialogueNextAllowedTime[ guy ] <- 0.0
	if ( !( guy in file.npcLastDialogue ) )
		file.npcLastDialogue[ guy ] <- ""
}

void function TrackDialogueSpeakerDeath( entity guy, string dialogue, float debounce )
{
	guy.EndSignal( "OnDestroy" )
	guy.EndSignal( "OnDeath" )
	table results = {
		waitTilDialogueEnd = false
	}

	OnThreadEnd
	(
		function(): ( guy, dialogue, results )
		{
			if ( IsValid( guy ) )
			{
				if ( !results.waitTilDialogueEnd )
					StopSoundOnEntity( guy, dialogue )
			}
		}
	)

	wait debounce // max wait time
	results.waitTilDialogueEnd = true // mark as we ended dialogue properly
}

// npc minimap and spawn checks
void function AddMinimapForNPC( entity guy, bool isHumanSized )
{
	if ( !IsAlive( guy ) )
		return
	
	// map
	guy.Minimap_AlwaysShow( TEAM_IMC, null )
	guy.Minimap_AlwaysShow( TEAM_MILITIA, null )
	foreach ( entity player in GetPlayerArray() )
		guy.Minimap_AlwaysShow( 0, player )
	guy.Minimap_SetHeightTracking( true )

	if ( isHumanSized )
		guy.Minimap_SetCustomState( eMinimapObject_npc.AI_TDM_AI )
}

// so you can set up a titan without have to make a npc pilot embarking it
// can't use localized string as pilotTitle, since pilot disembarking will and reset autotitan's title
void function ExtraSpawner_SetUpTitanSeatedPilot( entity titan, int team, int pilotHealth = 250, bool pilotInvulnerable = false, asset pilotModel = $"", string pilotTitle = "鐵馭" )
{
	entity titanSoul = titan.GetTitanSoul()
	if ( !IsValid( titanSoul ) )
		return

	// mark as having a pilot valid
	titanSoul.soul.seatedNpcPilot.isValid				= true
	titanSoul.soul.seatedNpcPilot.team 					= team

	if ( pilotModel == $"" ) // if no model given, we use a random one
		pilotModel = NPC_PILOT_ALLOWED_MODELS[ RandomInt( NPC_PILOT_ALLOWED_MODELS.len() ) ]
	titanSoul.soul.seatedNpcPilot.modelAsset 			= pilotModel
	titanSoul.soul.seatedNpcPilot.title 				= pilotTitle

	titanSoul.soul.seatedNpcPilot.isInvulnerable		= pilotInvulnerable

	titanSoul.soul.seatedNpcPilot.health				= pilotHealth

	// set up weapons
	array<string> mainWeapons = file.npcMainWeaponsTable[ "npc_pilot_elite" ]
	array<string> antiTitanWeapons = file.npcAntiTitanWeaponsTable[ "npc_pilot_elite" ]
	// main weapon
	if ( mainWeapons.len() > 0 )
	{
		NPCPilotWeaponStruct mainWeaponStruct
		mainWeaponStruct.weaponName = mainWeapons[ RandomInt( mainWeapons.len() ) ]
		titanSoul.soul.seatedNpcPilot.weapons.append( mainWeaponStruct )
	}
	// anti-titan
	if ( antiTitanWeapons.len() > 0 )
	{
		NPCPilotWeaponStruct antiTitanWeaponStruct
		antiTitanWeaponStruct.weaponName = antiTitanWeapons[ RandomInt( antiTitanWeapons.len() ) ]
		titanSoul.soul.seatedNpcPilot.weapons.append( antiTitanWeaponStruct )
	}
}

// npc pilot embarking npc titans
void function SetTitanSoulEmbarkedSettings( entity titan, string aiSet, string behavior, string title )
{
	entity soul = titan.GetTitanSoul()
	if ( !IsValid( soul ) )
		return
	EmbarkedNPCTitanStruct newStruct

	if ( aiSet != "" )
		newStruct.embarkedAiSet = aiSet
	if ( behavior != "" )
		newStruct.embarkedBehavior = behavior
	if ( title != "" )
		newStruct.embarkedTitle = title

	if ( !( soul in file.soulEmbarkedSettings ) )
		file.soulEmbarkedSettings[ soul ] <- newStruct
	else
		file.soulEmbarkedSettings[ soul ] = newStruct
}

void function ApplySoulSettingsForNpcPilotEmbarking( entity titan )
{
	entity soul = titan.GetTitanSoul()
	if ( !IsValid( soul ) )
		return

	EmbarkedNPCTitanStruct embarkedSettings

	if ( soul in file.soulEmbarkedSettings )
		embarkedSettings = file.soulEmbarkedSettings[ soul ]

	string newAiSet = embarkedSettings.embarkedAiSet
	string newBehavior = "behavior_sp_auto_titan" // default is become smarter than mp titans
	if ( embarkedSettings.embarkedBehavior != "" )
		newBehavior = embarkedSettings.embarkedBehavior
	string newTitle = ""
	if ( embarkedSettings.embarkedTitle != "" )
		newTitle = embarkedSettings.embarkedTitle
	else  // default is use print name
	{
		try // have to try-catch this since not all modded titans has GetSoulPlayerSettings() ( like for bisons )
		{
			string settings = GetSoulPlayerSettings( soul )
			var maintainTitle = Dev_GetPlayerSettingByKeyField_Global( settings, "keep_title_on_autotitan" )
			if ( maintainTitle != null && maintainTitle == 1 )
				newTitle = expect string( GetPlayerSettingsFieldForClassName( settings, "printname" ) )
		}
		catch( ex ) {}
	}

	asset modelName = titan.GetModelName() // maybe they're prime titans or something, save them to prevent changing aiSettings mess things up
	int fullBodygroup = titan.GetFullBodygroup() // also save bodygroup

	if ( newAiSet != "" ) // can't find a new aisetting
		titan.SetAISettings( newAiSet )
	if ( newBehavior != "" )
		titan.SetBehaviorSelector( newBehavior )
	if ( newTitle != "" )
		titan.SetTitle( newTitle )
	
	titan.SetModel( modelName ) // recover model
	titan.SetFullBodygroup( fullBodygroup ) // recover bodygroup. hitData is still in titan's settings so no worries
}

// utilities end

// copied from _ai_gamemodes, make them compatible with more settings
void function ExtraSpawner_SpawnDropShip( vector pos, vector rot, int team, string content, int count, void functionref( array<entity> guys ) squadHandler = null )
{  
	string squadName = MakeSquadName( team, UniqueString( "" ) )

	entity functionref( int team, vector origin, vector angles ) spawnFunc = GetDropshipSpawnFunc( content )
	if ( spawnFunc == null )
	{
		print( "[EXTRA SPAWNER] No Valid dropship spawn function for: " + content )
		return
	}

	CallinData drop
	drop.origin			= pos
	drop.yaw			= rot.y
	drop.dist			= 768
	drop.team			= team
	drop.squadname		= squadName
	SetDropTableSpawnFuncs( drop, spawnFunc, count )
	SetCallinStyle( drop, eDropStyle.ZIPLINE_NPC )
  
	thread RunDropshipDropoff( drop )
	
	WaitSignal( drop, "OnDropoff" )
	
	array<entity> guys = GetNPCArrayBySquad( squadName )
	
	foreach ( guy in guys )
	{
		ExtraSpawner_ApplyNPCWeapons( guy )
		guy.EnableNPCFlag( NPC_ALLOW_PATROL | NPC_ALLOW_INVESTIGATE | NPC_ALLOW_HAND_SIGNALS | NPC_ALLOW_FLEE )
	}
	
	if ( squadHandler != null )
		thread squadHandler( guys )
	else if ( file.squadHandlerFunc != null ) // default handler
		thread file.squadHandlerFunc( guys )
}

entity functionref( int, vector, vector ) function GetDropshipSpawnFunc( string content )
{
	switch ( content )
	{
		case "npc_soldier":
			return CreateSoldier_GrenadeSetup
		case "npc_spectre":
			return CreateSpectre_GrenadeSetup
		case "npc_stalker":
			return CreateStalker_GrenadeSetup
	}
	
	return null
}

// these are exact the same as CreateXXX() stuffs in _ai_spawn.gnut, but added ExtraSpawner_ApplyNPCGrenadeWeapon()
entity function CreateSoldier_GrenadeSetup( int team, vector origin, vector angles )
{
	entity npc = CreateSoldier( team, origin, angles )
	ExtraSpawner_ApplyNPCGrenadeWeapon( npc ) // grenade have to be given before DispatchSpawn()

	file.npcSpawnFromExtraSpawner[ npc ] <- true

	return npc
}

entity function CreateSpectre_GrenadeSetup( int team, vector origin, vector angles )
{
	entity npc = CreateSpectre( team, origin, angles )
	ExtraSpawner_ApplyNPCGrenadeWeapon( npc ) // grenade have to be given before DispatchSpawn()

	file.npcSpawnFromExtraSpawner[ npc ] <- true

	return npc
}

entity function CreateStalker_GrenadeSetup( int team, vector origin, vector angles )
{
	entity npc = CreateStalker( team, origin, angles )
	ExtraSpawner_ApplyNPCGrenadeWeapon( npc ) // grenade have to be given before DispatchSpawn()

	file.npcSpawnFromExtraSpawner[ npc ] <- true

	return npc
}
//

void function ExtraSpawner_SpawnDropPod( vector pos, vector rot, int team, string content, void functionref( array<entity> guys ) squadHandler = null, int droppodFlags = 0 )
{
	entity pod = CreateDropPod( pos, <0,0,0> )
	InitFireteamDropPod( pod, droppodFlags )
	
	// wait for launch
	waitthread LaunchAnimDropPod( pod, "pod_testpath", pos, rot )

	string squadName = MakeSquadName( team, UniqueString( "" ) )
	array<entity> guys
	for ( int i = 0; i < 4 ;i++ )
	{
		entity npc = CreateNPC( content, team, pos, <0,0,0> )
		ExtraSpawner_ApplyNPCGrenadeWeapon( npc ) // grenade have to be given before DispatchSpawn()

		file.npcSpawnFromExtraSpawner[ npc ] <- true
		DispatchSpawn( npc )

		SetSquad( npc, squadName )
		
		ExtraSpawner_ApplyNPCWeapons( npc )
		
		npc.SetParent( pod, "ATTACH", true )
		
		npc.EnableNPCFlag( NPC_ALLOW_PATROL | NPC_ALLOW_INVESTIGATE | NPC_ALLOW_HAND_SIGNALS | NPC_ALLOW_FLEE )
		guys.append( npc )
	}

	ActivateFireteamDropPod( pod, guys )

	if ( squadHandler != null )
		thread squadHandler( guys )
	else if ( file.squadHandlerFunc != null ) // default handler
		thread file.squadHandlerFunc( guys )
}

// default handler!
// tells infantry where to go
// In vanilla there seem to be preset paths ai follow to get to the other teams vone and capture it
// AI can also flee deeper into their zone suggesting someone spent way too much time on this
void function ExtraSpawner_SquadHandler( array<entity> guys )
{
	int team = guys[0].GetTeam()
	bool hasHeavyArmorWeapon = false // let's check if guys has heavy armor weapons
	foreach ( entity guy in guys )
	{
		if ( hasHeavyArmorWeapon ) // found heavy armor weapon
			break

		foreach ( entity weapon in guy.GetMainWeapons() )
		{
			if ( !weapon.GetWeaponSettingBool( eWeaponVar.titanarmor_critical_hit_required ) )
			{
				hasHeavyArmorWeapon = true
				break
			}
		}
	}
	//print( "hasHeavyArmorWeapon: " + string( hasHeavyArmorWeapon ) )

	array<entity> points
	vector point

	// Setup AI
	foreach ( guy in guys )
	{
		// add map
		AddMinimapForNPC( guy, true )
		guy.EnableNPCFlag( NPC_ALLOW_PATROL | NPC_ALLOW_INVESTIGATE | NPC_ALLOW_HAND_SIGNALS | NPC_ALLOW_FLEE )
		guy.AssaultSetGoalRadius( 1600 ) // 1600 is minimum for npc_stalker, works fine for others
	}

	// Every 5 - 15 secs get a closest target and go to them
	while ( true )
	{
		WaitFrame() // wait a frame each loop

		foreach ( guy in guys )
		{
			// remove dead guys
			ArrayRemoveDead( guys )
			// Stop func if our squad has been killed off
			if ( guys.len() == 0 )
				return
		}

		// Get point and send our whole squad to it
		points = []
		if ( hasHeavyArmorWeapon )
		{
			points.extend( GetNPCArrayOfEnemies( team ) )
			foreach ( entity player in GetPlayerArrayOfEnemies_Alive( team ) ) // also find titan players if they have heavy armor weapon
			{
				if ( player.IsTitan() ) // only search for npcs with light armor
					points.append( player )
			}
		}
		else
		{
			foreach ( entity npc in GetNPCArrayOfEnemies( team ) )
			{
				if ( npc.GetArmorType() != ARMOR_TYPE_HEAVY ) // only search for npcs with light armor
					points.append( npc )
			}
		}
		ArrayRemoveDead( points ) // remove dead targets
		if ( points.len() == 0 ) // can't find any points here
			continue

		// get nearest enemy and send our full squad to it
		entity enemy = GetClosest2D( points, guys[0].GetOrigin() )
		if ( !IsAlive( enemy ) )
			continue
		point = enemy.GetOrigin()
		foreach ( guy in guys )
		{
			if ( IsAlive( guy ) )
			{
				vector ornull clampedPos = NavMesh_ClampPointForAI( point, guy )
				if ( clampedPos == null )
					continue
				expect vector( clampedPos )
				guy.AssaultPoint( clampedPos )
			}
		}

		wait RandomFloatRange(5.0,15.0)
	}
}

entity function ExtraSpawner_SpawnTitan( vector pos, vector rot, int team, bool standUp = true, void functionref( entity titan ) titanHandler = null, string spawnName = "" )
{
	array<string> registeredTitans
	foreach ( string titanName, TitanSpawnStruct titanStruct in file.titanSpawnList )
		registeredTitans.append( titanName )

	// can't find any titan
	if ( registeredTitans.len() <= 0 )
		return

	string setFile = ""
	string aiSet = ""
	string executionRef = "" // funny with MeleeSyncedNPC
	// after being embarked
	string embarkedAiSet = ""
	string embarkedBehavior = ""
	string embarkedTitle = ""
	void functionref( entity ) loadoutFunction = null
	// team skin
	int imcSkinIndex = -1
	int mltSkinIndex = -1

	// get a registered titan
	// leaving spawn name to "" meaning we'll pick a random one
	// we also try to pick a random titan if given spawn name not found
	if ( spawnName == "" || !registeredTitans.contains( spawnName ) )
		spawnName = registeredTitans[ RandomInt( registeredTitans.len() ) ]

	TitanSpawnStruct currentTitan = file.titanSpawnList[ spawnName ]
	setFile 			= currentTitan.setFile
	aiSet 				= currentTitan.aiSet
	executionRef 		= currentTitan.executionRef
	embarkedAiSet 		= currentTitan.embarkedAiSet
	embarkedBehavior 	= currentTitan.embarkedBehavior
	embarkedTitle 		= currentTitan.embarkedTitle
	loadoutFunction		= currentTitan.loadoutFunction
	imcSkinIndex 		= currentTitan.imcSkinIndex
	mltSkinIndex 		= currentTitan.mltSkinIndex
	
	// friendly warning
	foreach ( entity player in GetPlayerArrayOfTeam( team ) )
	    Remote_CallFunction_Replay( player, "ServerCallback_ReplacementTitanSpawnpoint", pos.x, pos.y, pos.z, Time() + 5 )
	// enemy warning
	thread HotDrop_Spawnpoint( pos, team, 5.0, false, damagedef_titan_fall )

	entity titan = CreateNPC( "npc_titan", team, pos, rot )
	SetSpawnOption_AISettings( titan, aiSet )
    titan.ai.titanSpawnLoadout.setFile = setFile
    OverwriteLoadoutWithDefaultsForSetFile( titan.ai.titanSpawnLoadout )

	file.npcSpawnFromExtraSpawner[ titan ] <- true
	DispatchSpawn( titan )

	// set up embarked behavior
	SetTitanSoulEmbarkedSettings( titan, embarkedAiSet, embarkedBehavior, embarkedTitle )

	// update team specific skin
	if ( team == TEAM_IMC && imcSkinIndex > -1 )
		titan.SetSkin( imcSkinIndex )
	if ( team == TEAM_MILITIA && mltSkinIndex > -1 )
		titan.SetSkin( mltSkinIndex )

	// titan won't have a soul until they DispatchSpawn()
	if ( executionRef != "" )
		titan.GetTitanSoul().soul.titanLoadout.titanExecution = executionRef
	if ( loadoutFunction != null ) // modded titan!!
		loadoutFunction( titan )

	thread NPCTitanHotdrops( titan, standUp )

	if ( titanHandler != null )
		thread titanHandler( titan )
	else if ( standUp && GetNPCHandlerForClass( "npc_titan" ) != null ) // only stood up titans run handlers
		thread GetNPCHandlerForClass( "npc_titan" )( titan )

	return titan
}

entity function ExtraSpawner_SpawnBossTitan( vector pos, vector rot, int team, string spawnName = "", int titanType = TITAN_AUTO )
{
	array<string> registeredTitans
	foreach ( string titanName, BossTitanSpawnStruct titanStruct in file.bossTitanSpawnList )
		registeredTitans.append( titanName )

	// can't find any titan
	if ( registeredTitans.len() <= 0 )
		return

	string bossName = ""

	string setFile = ""
	string aiSet = ""
	string behavior = ""
	string executionRef = "" // funny with MeleeSyncedNPC
	string bossTitle = ""
	string pilotTitle = ""
	asset characterModel = $""
	
	void functionref( entity ) loadoutFunction = null
	int skinIndex = -1
	int decalIndex = -1

	// get a registered titan
	// leaving spawn name to "" meaning we'll pick a random one
	// we also try to pick a random titan if given spawn name not found
	if ( spawnName == "" || !registeredTitans.contains( spawnName ) )
		spawnName = registeredTitans[ RandomInt( registeredTitans.len() ) ]

	BossTitanSpawnStruct currentTitan = file.bossTitanSpawnList[ spawnName ]
	bossName			= currentTitan.bossName
	setFile 			= currentTitan.setFile
	aiSet 				= currentTitan.aiSet
	behavior 			= currentTitan.behavior
	executionRef 		= currentTitan.executionRef
	bossTitle 			= currentTitan.bossTitle
	pilotTitle			= currentTitan.pilotTitle
	characterModel 		= currentTitan.characterModel

	loadoutFunction		= currentTitan.loadoutFunction
	skinIndex 			= currentTitan.skinIndex
	decalIndex 			= currentTitan.decalIndex

	entity titan = CreateNPC( "npc_titan", team, pos, rot )
	SetSpawnOption_AISettings( titan, aiSet )

	// setup boss
	titan.ai.bossCharacterName = bossName
	titan.ai.bossTitanType = titanType // set to TITAN_MERC before DispatchSpawn() will play a intro

    titan.ai.titanSpawnLoadout.setFile = setFile
    OverwriteLoadoutWithDefaultsForSetFile( titan.ai.titanSpawnLoadout )

	// we'll do intro, hide on spawn
	if ( titanType == TITAN_MERC )
	{
		HideName( titan )
		titan.Hide()
	}

	file.npcSpawnFromExtraSpawner[ titan ] <- true
	DispatchSpawn( titan )

	if ( skinIndex > -1 )
		titan.SetSkin( skinIndex )
	if ( decalIndex > -1 )
		titan.SetDecal( decalIndex ) // nose art
	// titan won't have a soul until they DispatchSpawn()
	entity titanSoul = titan.GetTitanSoul()
	if ( executionRef != "" )
		titan.GetTitanSoul().soul.titanLoadout.titanExecution = executionRef
	if ( loadoutFunction != null ) // modded titan!!
		loadoutFunction( titan )

	// pilot settings!
	// can't use localized string as pilotTitle, since pilot disembarking will and reset autotitan's title
	ExtraSpawner_SetUpTitanSeatedPilot( titan, team, 1500, false, characterModel, pilotTitle )

	// merc boss titan behavior
	if ( titanType == TITAN_MERC )
	{
		// amped behavior
		// health settings. 4x health, 75% damage reduction ≈ 16x health, without annoying health bar
		titan.SetMaxHealth( titan.GetMaxHealth() * 4 )
		titan.SetHealth( titan.GetMaxHealth() )
		MpBossTitan_SetDamageScale( titan, 1.5 ) // they can deal higher damage
		MpBossTitan_SetDamageReductionScale( titan, 0.75 )
		// attack settings
		titan.kv.WeaponProficiency = eWeaponProficiency.PERFECT // they can shoot very nice
		titan.SetCapabilityFlag( bits_CAP_SYNCED_MELEE_ATTACK, false ) // disable synced melee behavior, we use melee_synced_npc
		// core ability
		TitanHealth_SetTitanCoreBuilderMultiplier( titan, 5.0 ) // want them get core abilities faster
	}
	else // normal embarked titan behavior
		ExtraSpawner_SetUpNPCEmbarkedTitan( titan )

	titan.SetTitle( bossTitle ) // update title
	titan.SetBehaviorSelector( behavior ) // become smarter, since pilot has control of it

	// set up embarked behavior, we may feature npc pilot disembarking in future?
	SetTitanSoulEmbarkedSettings( titan, setFile, behavior, bossTitle )

	// titan spawn with intro don't have to hotdrop
	if ( titanType != TITAN_MERC )
		thread NPCTitanHotdrops( titan, true )

	// we'll do intro, show again after DispatchSpawn(). ShowName() is handled in intro
	if ( titanType == TITAN_MERC )
		titan.Show()

	// titan handler
	if ( GetNPCHandlerForClass( "npc_titan" ) != null )
		thread GetNPCHandlerForClass( "npc_titan" )( titan )

	return titan
}

entity function ExtraSpawner_SpawnTitanBT( vector pos, vector rot, int team, void functionref( entity titan ) titanHandler = null )
{
	foreach ( entity player in GetPlayerArray() )
	{
	    Remote_CallFunction_Replay( player, "ServerCallback_ReplacementTitanSpawnpoint", pos.x, pos.y, pos.z, Time() + 5 )
	}
	string squadName = MakeSquadName( team, UniqueString( "ZiplineTable" ) )
	entity titan = CreateNPC( "npc_titan", team, pos, rot )
	SetSpawnOption_AISettings( titan, "npc_titan_buddy")
	SetSpawnOption_Titanfall( titan )
	SetSpawnOption_Warpfall( titan )
	//SetSpawnOption_NPCTitan( titan, TITAN_HENCH ) // mp don't need boss titan setting
    titan.ai.titanSpawnLoadout.setFile = "titan_buddy"
    OverwriteLoadoutWithDefaultsForSetFile( titan.ai.titanSpawnLoadout )

	file.npcSpawnFromExtraSpawner[ titan ] <- true
	DispatchSpawn( titan )

	titan.TakeWeaponNow( "mp_titanweapon_xo16_shorty" ) // don't use a one-shot killing xo16!
	titan.GiveWeapon( "mp_titanweapon_xo16_vanguard" )
	titan.GetOffhandWeapon( OFFHAND_SPECIAL ).AddMod( "slow_recovery_vortex" ) // fix mod
	titan.GetOffhandWeapon( OFFHAND_ORDNANCE ).AddMod( "upgradeCore_MissileRack_Vanguard" ) // fix mod: lock on heavy armor target only
	titan.GetOffhandWeapon( OFFHAND_EQUIPMENT ).AddMod( "npc_bt_balance" ) // balance core ability
	//titan.SetSkin(1) // sarah skin
	SetSquad( titan, squadName )

	if ( titanHandler != null )
		thread titanHandler( titan )

	return titan
}

entity function ExtraSpawner_SpawnTitanWithPilot( vector pos, vector rot, int team, string spawnName = "" )
{
	entity titan = ExtraSpawner_SpawnTitan( pos, rot, team, true, null, spawnName )

	// titan won't have a soul until they DispatchSpawn()
	// can't use localized string as pilotTitle, since pilot disembarking will and reset autotitan's title
	ExtraSpawner_SetUpTitanSeatedPilot( titan, team, 1000, false, $"", "鐵馭" )
	
	titan.SetTitle( "#NPC_PILOT" )
	// apply amped behaviors
	ExtraSpawner_SetUpNPCEmbarkedTitan( titan )
	ApplySoulSettingsForNpcPilotEmbarking( titan ) // become smarter, since pilot has control of it

	// forced titan handler
	if ( GetNPCHandlerForClass( "npc_titan" ) != null )
		thread GetNPCHandlerForClass( "npc_titan" )( titan )

	return titan
}

void function ExtraSpawner_SpawnNPCInDropPod( vector pos, vector rot, int team, string content, int amount, void functionref( array<entity> guys ) squadHandler = null )
{
	entity pod = CreateDropPod( pos, <0,0,0> )
	InitFireteamDropPod( pod, eDropPodFlag.DISSOLVE_AFTER_DISEMBARKS ) // fast dissolving, try not to stuck npcs inside
	
	waitthread LaunchAnimDropPod( pod, "pod_testpath", pos, rot )

	string squadName = MakeSquadName( team, UniqueString( "" ) )
	array<entity> guys
	for ( int i = 0; i < amount; i++ )
	{
		entity spawnNpc = CreateNPC( content, team, pos, rot )

		file.npcSpawnFromExtraSpawner[ spawnNpc ] <- true
		DispatchSpawn( spawnNpc ) // never delay dispatchSpawn()

		SetSquad( spawnNpc, squadName )

		spawnNpc.SetParent( pod, "ATTACH", true )
		guys.append( spawnNpc )
	}

	// if npcs spawned from here, we assume they don't have deploy animations, just clear parent for them
	thread DropPodActiveThink( pod )
	foreach ( entity guy in guys )
	{
		if ( IsAlive( guy ) )
			guy.ClearParent()
	}

	if ( squadHandler != null )
		thread squadHandler( guys )
	else if ( file.squadHandlerFunc != null ) // default handler
		thread file.squadHandlerFunc( guys )
}

void function ExtraSpawner_SpawnSpecialistGruntDropShip( vector pos, vector rot, int team, string content, int count, string leaderAiSet = "npc_soldier_pve_specialist", int leaderHealth = 350, void functionref( array<entity> guys ) squadHandler = null )
{  
	string squadName = MakeSquadName( team, UniqueString( "" ) )

	entity functionref( int team, vector origin, vector angles ) spawnFunc = GetDropshipSpawnFunc( content )
	if ( spawnFunc == null )
	{
		print( "[EXTRA SPAWNER] No Valid dropship spawn function for: " + content )
		return
	}

	CallinData drop
	drop.origin			= pos
	drop.yaw			= rot.y
	drop.dist			= 768
	drop.team			= team
	drop.squadname		= squadName
	// setup spawnFucs
	drop.npcSpawnFuncs.append( 
		entity function( int team, vector origin, vector angles ) : ( leaderAiSet )
		{
			return CreateSpecialistGrunt_NonSetup( team, origin, angles, leaderAiSet )
		}
	)
	// others are normal spawn functions
	for ( int i = 0; i < count - 1; i++ ) 
		drop.npcSpawnFuncs.append( spawnFunc )

	SetCallinStyle( drop, eDropStyle.ZIPLINE_NPC )
  
	thread RunDropshipDropoff( drop )
	
	WaitSignal( drop, "OnDropoff" )
	
	array<entity> guys = GetNPCArrayBySquad( squadName )
	
	foreach ( int i, guy in guys )
	{
		bool isLeader = i == 0 // leader always spawn first, have to set here
		if ( isLeader )
		{
			SetUpSpecialistGrunt( guy, leaderAiSet )
			guy.SetMaxHealth( leaderHealth )
			guy.SetHealth( leaderHealth )
		}

		// hardcoded here, setup grunt weapon specific
		bool sniperGrunt = isLeader && leaderAiSet == "npc_soldier_sidearm"
		bool guardGrunt = isLeader && leaderAiSet == "npc_soldier_pve_eliteguard"
		bool replaceAllWeapons = !sniperGrunt && !guardGrunt
		//print( "sniperGrunt: " + string( sniperGrunt ) )
		ExtraSpawner_ApplyNPCWeapons( guy, replaceAllWeapons )

		guy.EnableNPCFlag( NPC_ALLOW_PATROL | NPC_ALLOW_INVESTIGATE | NPC_ALLOW_HAND_SIGNALS | NPC_ALLOW_FLEE )
	}
	
	if ( squadHandler != null )
		thread squadHandler( guys )
	else if ( file.squadHandlerFunc != null ) // default handler
		thread file.squadHandlerFunc( guys )
}

// spawn a normal specialist grunt here, we setup them up later, since DispatchSpawn() is done in CreateNPCSForDropship()
entity function CreateSpecialistGrunt_NonSetup( int team, vector origin, vector angles, string aiSet )
{
	entity npc = CreateNPC( "npc_soldier", team, origin, angles )
	SetSpawnOption_AISettings( npc, aiSet )

	bool specialistGrunt = aiSet == "npc_soldier_pve_specialist"
	bool changeGrenade = !specialistGrunt
	//print( "specialistGrunt: " + string( sniperGrunt ) )
	if ( changeGrenade )
		ExtraSpawner_ApplyNPCGrenadeWeapon( npc ) // grenade have to be given before DispatchSpawn()
	
	return npc
}

void function ExtraSpawner_SpawnSpecialistGruntDropPod( vector pos, vector rot, int team, string content, string leaderAiSet = "npc_soldier_pve_specialist", int leaderHealth = 350, void functionref( array<entity> guys ) squadHandler = null, int droppodFlags = 0 )
{
	entity pod = CreateDropPod( pos, <0,0,0> )
	InitFireteamDropPod( pod, droppodFlags ) // eDropPodFlag.DISSOLVE_AFTER_DISEMBARKS

	waitthread LaunchAnimDropPod( pod, "pod_testpath", pos, rot )

	string squadName = MakeSquadName( team, UniqueString( "" ) )
	array<entity> guys
	for ( int i = 0; i < 4 ;i++ )
	{
		bool isLeader = i == 0 // leader always spawn first, have to set here
		entity npc
		if ( isLeader ) // specialist as leader
			npc = ExtraSpawner_SpawnSpecialistGrunt( pos, <0,0,0>, team, leaderAiSet, leaderHealth )
		else
		{
			npc = CreateNPC( content, team, pos, <0,0,0> )
			ExtraSpawner_ApplyNPCGrenadeWeapon( npc ) // grenade have to be given before DispatchSpawn()

			file.npcSpawnFromExtraSpawner[ npc ] <- true
			DispatchSpawn( npc )
		}

		SetSquad( npc, squadName )
		// hardcoded here, setup grunt weapon specific
		bool sniperGrunt = isLeader && leaderAiSet == "npc_soldier_sidearm"
		bool guardGrunt = isLeader && leaderAiSet == "npc_soldier_pve_eliteguard"
		bool replaceAllWeapons = !sniperGrunt && !guardGrunt
		//print( "sniperGrunt: " + string( sniperGrunt ) )
		ExtraSpawner_ApplyNPCWeapons( npc, replaceAllWeapons )
		
		npc.SetParent( pod, "ATTACH", true )
		
		npc.EnableNPCFlag( NPC_ALLOW_PATROL | NPC_ALLOW_INVESTIGATE | NPC_ALLOW_HAND_SIGNALS | NPC_ALLOW_FLEE )
		guys.append( npc )
	}
		
	ActivateFireteamDropPod( pod, guys )

	if ( squadHandler != null )
		thread squadHandler( guys )
	else if ( file.squadHandlerFunc != null ) // default handler
		thread file.squadHandlerFunc( guys )
}

entity function ExtraSpawner_SpawnSpecialistGrunt( vector pos, vector rot, int team, string aiSet = "npc_soldier_pve_specialist", int maxHealth = 350 )
{
	entity npc = CreateSpecialistGrunt_NonSetup( team, pos, rot, aiSet )

	file.npcSpawnFromExtraSpawner[ npc ] <- true
	DispatchSpawn( npc )

	SetUpSpecialistGrunt( npc, aiSet )

	npc.SetMaxHealth( maxHealth )
	npc.SetHealth( maxHealth )

	return npc
}


const array<string> SPECIALIST_VALID_DRONETYPES = 
[ 
	"npc_drone_beam", 
	"npc_drone_rocket", 
	"npc_drone_plasma" 
]

const array<string> SNIPER_VALID_SIDEARMS =
[
	"mp_weapon_semipistol",
	"mp_weapon_autopistol",
	"mp_weapon_shotgun_pistol",
	// wingmans needs damage buff(respawn messed up)
	"mp_weapon_wingman_n",
	"mp_weapon_wingman",
]

void function SetUpSpecialistGrunt( entity npc, string aiSet )
{
	// hardcoded here..
	int team = npc.GetTeam()
	switch( aiSet )
	{
		case "npc_soldier_pve_specialist": // drone summoner grunt
			if ( team == TEAM_MILITIA )
				npc.SetModel( $"models/humans/heroes/mlt_hero_barker.mdl" )
			else
				npc.SetModel( $"models/humans/heroes/imc_hero_marder.mdl" )
			
			npc.SetTitle( "#NPC_SPECIALIST" )
			// modified signal in _ai_drone.gnut, vanilla won't register it
			npc.Signal( "ForceStopDroneSpawn" ) // stop it's drone spawn think

			string droneType = SPECIALIST_VALID_DRONETYPES[ RandomInt( SPECIALIST_VALID_DRONETYPES.len() ) ]
			thread DroneGruntThink( npc, droneType ) // force set it again
			break

		case "npc_soldier_shield_captain": // shield captain
			npc.SetModel( $"models/humans/grunts/imc_grunt_shield_captain.mdl" )

			npc.SetTitle( "#NPC_SOLDIER_SHIELD_CAPTAIN" )
			npc.Signal( "ForceStopShield" ) // stop it's shield
			// force set them again here
			npc.DisableNPCFlag( NPC_ALLOW_FLEE | NPC_ALLOW_HAND_SIGNALS | NPC_USE_SHOOTING_COVER | NPC_CROUCH_COMBAT )
			thread WaitForShieldCaptainDrop( npc ) // start shield after being clear parented
			break

		case "npc_soldier_sidearm": // sniper grunt
			//npc.SetAISettings( "npc_soldier_shield_captain" ) // re-assign aiset to shield captain: higher damage threshold
			//npc.Signal( "ForceStopShield" ) // stop it's shield
			if ( team == TEAM_MILITIA )
				npc.SetModel( $"models/humans/grunts/mlt_grunt_lmg.mdl" )
			else
				npc.SetModel( $"models/humans/grunts/imc_grunt_lmg.mdl" )

			npc.SetTitle( "狙擊步兵" )
			// stronger behavior
			npc.SetBehaviorSelector( "behavior_sp_soldier" ) // they'll switch to pistol if needed
			npc.kv.WeaponProficiency = eWeaponProficiency.PERFECT // they can shoot very nice

			// special weapons, hardcoded!
			// take off existing main weapons, or sometimes they'll have a archer
			foreach ( entity weapon in npc.GetMainWeapons() )
				npc.TakeWeaponNow( weapon.GetWeaponClassName() )
			npc.GiveWeapon( "mp_weapon_sniper", ["pve_elite", "burn_mod_sniper"] )
			npc.SetActiveWeaponByName( "mp_weapon_sniper" )

			string sideArmName = SNIPER_VALID_SIDEARMS[ RandomInt( SNIPER_VALID_SIDEARMS.len() ) ]
			entity sideArm = npc.GiveWeapon( sideArmName )
			//sideArm.AddMod( "npc_sniper_grunt" ) // removed, which is overpowered

			npc.EnableNPCFlag( NPC_NO_WEAPON_DROP ) // due sniper grunts have specific weapon, make them never drop weapons

			break

		case "npc_soldier_pve_eliteguard": // elite guard grunt
			if ( team == TEAM_MILITIA )
				npc.SetModel( $"models/humans/grunts/mlt_grunt_shotgun.mdl" )
			else
				npc.SetModel( $"models/humans/grunts/imc_grunt_shotgun.mdl" )

			npc.SetTitle( "菁英護衛" )
			npc.kv.WeaponProficiency = eWeaponProficiency.PERFECT // they can shoot very nice

			// this should be a external const, but we can't assign things if it being a const
			table< string, array<string> > guardValidWeaponMods
			guardValidWeaponMods["mp_weapon_smart_pistol"] <- []
			guardValidWeaponMods["mp_weapon_alternator_smg"] <- []
			guardValidWeaponMods["mp_weapon_shotgun_doublebarrel_tfo"] <- ["projectile_shotgun_npc"] // modified shotgun variant that only suitable for npcs

			// special weapons, hardcoded!
			// take off existing main weapons, or sometimes they'll have a archer
			foreach ( entity weapon in npc.GetMainWeapons() )
				npc.TakeWeaponNow( weapon.GetWeaponClassName() )

			// assign specific weapon and mods
			array<string> validWeapons
			foreach ( weapon, mods in guardValidWeaponMods )
				validWeapons.append( weapon )

			string weaponToChoose = validWeapons[ RandomInt( validWeapons.len() ) ]
			array<string> mods = guardValidWeaponMods[ weaponToChoose ]
			npc.GiveWeapon( weaponToChoose, mods )
			npc.SetActiveWeaponByName( weaponToChoose )

			npc.EnableNPCFlag( NPC_NO_WEAPON_DROP ) // elite guard grunts never drops weapon

			break
	}
}

void function WaitForShieldCaptainDrop( entity npc )
{
	npc.EndSignal( "OnDestroy" )
	npc.EndSignal( "OnDeath" )

	WaitFrame() // wait for npc being set into dropship
	while( IsValid( npc.GetParent() ) )
		WaitFrame()

	thread ActivatePersonalShield( npc )
}

void function ExtraSpawner_SpawnProwlerSquadDropPod( vector pos, vector rot, int team, void functionref( array<entity> guys ) squadHandler = null )
{
	entity pod = CreateDropPod( pos, <0,0,0> )
	InitFireteamDropPod( pod, eDropPodFlag.DISSOLVE_AFTER_DISEMBARKS ) // fast dissolving, try not to stuck prowlers inside

	waitthread LaunchAnimDropPod( pod, "pod_testpath", pos, rot )

	string squadName = MakeSquadName( team, UniqueString( "" ) )
	array<entity> guys
	for ( int i = 0; i < 5 ;i++ )
	{
		// 3 small prowlers and 2 normal prowlers
		entity npc = CreateNPC( "npc_prowler", team, pos, <0,0,0> )

		float prowlerScale = RandomFloatRange( 0.5, 0.7 )
		if ( i >= 2 ) // small prowlers
			npc.kv.modelscale = prowlerScale

		file.npcSpawnFromExtraSpawner[ npc ] <- true
		DispatchSpawn( npc )

		if ( i < 2 ) // normal prowlers
			npc.SetBehaviorSelector( "behavior_prowler_cqb" ) // better behavior
		else // small prowlers, scale health
		{
			npc.SetMaxHealth( npc.GetMaxHealth() * prowlerScale )
			npc.SetHealth( npc.GetMaxHealth() )
		}

		SetSquad( npc, squadName )
		
		npc.SetParent( pod, "ATTACH", true )
		guys.append( npc )

		file.isProwlerSquadmate[ npc ] <- true // mark the prowler as prowler squadmate, for handling it's damage scale
	}
	
	// if npcs spawned from here, we assume they don't have deploy animations, just clear parent for them
	thread DropPodActiveThink( pod )
	foreach ( entity guy in guys )
	{
		if ( IsAlive( guy ) )
			guy.ClearParent()
	}
	
	if ( squadHandler != null )
		thread squadHandler( guys )
	else if ( file.squadHandlerFunc != null ) // default handler
		thread file.squadHandlerFunc( guys )
}

void function ExtraSpawner_SpawnGunShip( vector pos, vector rot, int team )
{
	entity gunship = CreateNPC("npc_gunship", team, pos, rot )
	HideName( gunship ) // won't make it's info target( or health bar ) teleport into battle
	file.npcSpawnFromExtraSpawner[ gunship ] <- true
	DispatchSpawn( gunship )

	SetDefaultMPEnemyHighlight( gunship )
	thread PlayAnim( gunship , "st_AngelCity_IMC_Win_ComeIn" ) // flying anim
    WaittillAnimDone( gunship )
	ShowName( gunship ) // show info target again

	vector spawnpoint = gunship.GetOrigin()
	vector spawnang = gunship.GetAngles()
	if ( IsValid( gunship ) )
		gunship.Destroy()

	entity gunship2 = CreateNPC( "npc_gunship", team, spawnpoint, spawnang )
	gunship2.e.hasDefaultEnemyHighlight = true // mark them as hasDefaultHighlight, so they'll save highlights after phase shift
	SetDefaultMPEnemyHighlight( gunship2 )

	file.npcSpawnFromExtraSpawner[ gunship2 ] <- true
	DispatchSpawn( gunship2 )

	array<string> gunshipWeapons =
	[
		"mp_weapon_gunship_launcher", // might be most useful weapon?
		//"mp_weapon_gunship_missile", // temp removed
	]
	string currentWeapon = gunshipWeapons[ RandomInt( gunshipWeapons.len() ) ]
	gunship2.TakeWeaponNow( "mp_weapon_gunship_missile" ) // take default weapon
	gunship2.GiveWeapon( currentWeapon ) // removed [ "npc_elite_weapon" ]
	gunship2.SetActiveWeaponByName( currentWeapon )

	gunship2.kv.WeaponProficiency = eWeaponProficiency.VERYGOOD // they can shoot very nice
}

void function ExtraSpawner_SpawnPilotCanEmbark( vector pos, vector rot, int team, string spawnName = "" )
{
	// a dummy pod for getting droppod impact time
	float podLaunchTime = expect float ( GetDropPodAnimDuration() )

	entity pilot = ExtraSpawner_SpawnPilotElite( pos, rot, team )
	pilot.EndSignal( "OnDeath" )
	pilot.EndSignal( "OnDestroy" )
	pilot.EnableNPCFlag( NPC_IGNORE_ALL ) // so they will mostly try to embark, clean it up later
	// attach to a droppod
	entity pod = CreateDropPod( pos, <0,0,0> )
	InitFireteamDropPod( pod, eDropPodFlag.DISSOLVE_AFTER_DISEMBARKS ) // for fast dissolving
	pilot.SetParent( pod, "ATTACH", true )
	pilot.Hide() // we show them after pod landing! try to avoid sometimes they have wrong animation inside a droppod

	thread LaunchAnimDropPod( pod, "pod_testpath", pos, rot )

	wait 3 // send titan a little bit later
	entity titan = ExtraSpawner_SpawnTitanForPilot( pilot, pos, rot, spawnName )
	// now using my own embarking function
	local embarkSet = FindBestEmbarkForNpcAnim( pilot, titan ) // passing a same embark set
	pilot.SetNPCMoveSpeedScale( 1.8 ) // want this pilot run to titan's start point faster
	thread ExtraSpawner_NpcPilotRunsToEmbarkTitan( pilot, titan, embarkSet ) // passing a same embark set
	
	thread ForceStartTitan( titan, pilot, 10 ) // to fit ownerLifeTimeCheck(), if pilot died instantly we stand the titan
	titan.EndSignal( "OnDeath" )
	titan.EndSignal( "OnDestroy" )

	OnThreadEnd( 
		function(): ( pilot, titan )
		{
			if( !IsAlive( titan ) )
				return
			if( !IsAlive( pilot ) )
			{
				thread StandUnboardedTitan( titan )
				return
			}
		}
	)

	wait podLaunchTime - 2.5 // wait for pod launch complete( wait 0.5s more )
	pilot.Show()

	ActivateFireteamDropPod( pod, [ pilot ] )
	thread PilotSpawnProtection( pilot, titan, 15 ) // at least don't let players kill pilots while their titans're not landing

	NpcPilotSetPetTitan( pilot, titan )
	titan.SetTitle( pilot.GetTitle() + " 的自動泰坦" )
	titan.WaitSignal( "TitanHotDropComplete" )
	
	// now using my own embarking function
	waitthread ExtraSpawner_NpcPilotRunsToEmbarkTitan( pilot, titan, embarkSet ) // passing a same embark set
	thread NpcPilotEmbarksTitan( pilot, titan )
}

// taken from _ai_pilots, modified
void function ExtraSpawner_NpcPilotRunsToEmbarkTitan( entity pilot, entity titan, embarkSet )
{
	titan.EndSignal( "OnDeath" )
	titan.EndSignal( "OnDestroy" )
	pilot.EndSignal( "OnDeath" )
	pilot.EndSignal( "OnDestroy" )
	pilot.EndSignal( "StopRunsToEmbark" ) // for manually cancel embarks

	pilot.SetNoTarget( true )
	pilot.Anim_Stop()
	// want they move faster to their titans
	pilot.DisableNPCMoveFlag( NPCMF_INDOOR_ACTIVITY_OVERRIDE | NPCMF_FOLLOW_SAFE_PATHS )
	pilot.EnableNPCMoveFlag( NPCMF_DISABLE_DANGEROUS_AREA_DISPLACEMENT | NPCMF_IGNORE_CLUSTER_DANGER_TIME | NPCMF_PREFER_SPRINT )
	pilot.DisableArrivalOnce( true )
	bool canMoveAndShoot = pilot.GetCapabilityFlag( bits_CAP_MOVE_SHOOT )
	pilot.SetCapabilityFlag( bits_CAP_MOVE_SHOOT, false )

	OnThreadEnd(
		function () : ( pilot, canMoveAndShoot )
		{
			//print( "NpcPilotRunsToEmbarkTitan: OnThreadEnd()!" )
			if ( !IsAlive( pilot ) )
				return

			pilot.SetNoTarget( false )
			pilot.EnableNPCMoveFlag( NPCMF_INDOOR_ACTIVITY_OVERRIDE | NPCMF_FOLLOW_SAFE_PATHS )
			pilot.DisableNPCMoveFlag( NPCMF_DISABLE_DANGEROUS_AREA_DISPLACEMENT | NPCMF_IGNORE_CLUSTER_DANGER_TIME | NPCMF_PREFER_SPRINT )
			pilot.SetCapabilityFlag( bits_CAP_MOVE_SHOOT, canMoveAndShoot )
		}
	)

	local titanSubClass = GetSoulTitanSubClass( titan.GetTitanSoul() )
	string pilotAnim = GetAnimFromAlias( titanSubClass, embarkSet.animSet.thirdPersonKneelingAlias )

	pilot.ClearAllEnemyMemory()
	thread RunToAnimStartForced_Deprecated( pilot, pilotAnim, titan, "hijack", true, true )
}

void function StandUnboardedTitan( entity titan, bool doHandler = false )
{
	titan.EndSignal( "OnDestroy" )

	waitthread WaitForHotdropToEnd( titan )

	titan.Anim_Stop() // stop current animation
	waitthread PlayAnimGravity( titan, "at_hotdrop_quickstand" )
	// adding here: mark the titan as stand
	SetStanceStand( titan.GetTitanSoul() )

	titan.ClearInvulnerable()

	if ( doHandler )
	{
		// titan handler
		if ( GetNPCHandlerForClass( "npc_titan" ) != null )
			thread GetNPCHandlerForClass( "npc_titan" )( titan )
	}
}

entity function ExtraSpawner_SpawnPilotElite( vector pos, vector rot, int team )
{
	entity pilot = CreateNPC( "npc_pilot_elite", team, pos, rot )//CreateNPC( "npc_soldier", team, pos, rot )
	// initializing
	pilot.s.petTitan <- null
	pilot.s.nextTitanRespawnAvailable <- null

	ExtraSpawner_ApplyNPCGrenadeWeapon( pilot ) // grenade have to be given before DispatchSpawn()

	file.npcSpawnFromExtraSpawner[ pilot ] <- true
	DispatchSpawn( pilot ) // don't delayed dispatchSpawn()

	ExtraSpawner_SetUpNPCPilot( pilot )
	asset modelAsset = NPC_PILOT_ALLOWED_MODELS[ RandomInt(NPC_PILOT_ALLOWED_MODELS.len()) ]
	pilot.SetModel( modelAsset )
	pilot.SetMaxHealth( 1000 )
	pilot.SetHealth( 1000 )
	pilot.SetTitle( "鐵馭" ) // "#NPC_PILOT", using a localized string will cause auto-titan's title to be wrong

	ExtraSpawner_ApplyNPCWeapons( pilot )

	return pilot
}

void function ExtraSpawner_SetUpNPCPilot( entity pilot )
{
	// initializing
	if ( !( "petTitan" in pilot.s ) )
		pilot.s.petTitan <- null
	if ( !( "nextTitanRespawnAvailable" in pilot.s ) )
		pilot.s.nextTitanRespawnAvailable <- null

	pilot.EnableNPCFlag( NPC_ALLOW_PATROL | NPC_ALLOW_INVESTIGATE | NPC_ALLOW_FLEE ) // hardcoded!
	pilot.SetNPCMoveSpeedScale( 1.25 ) // want pilots move faster
	pilot.kv.WeaponProficiency = eWeaponProficiency.PERFECT // they can shoot perfectly

	// disabled SelectSchedule_SwitchWeapon in their behavior, since pilot model not included "pete_agent.mdl", no animations for switching to pistols
	pilot.SetEnemyChangeCallback( OnEnemyChanged_SwitchToHeavyArmorWeapon ) 

	AddEntityCallback_OnDamaged( pilot, NPCPilotDamageAdjustments ) // don't let stepping on easily kill them
	pilot.e.hasDefaultEnemyHighlight = true // mark them as hasDefaultHighlight, so they'll save highlights after phase shift
	SetDefaultMPEnemyHighlight( pilot )
}

void function PilotSpawnProtection( entity pilot, entity titan, float duration )
{
	pilot.EndSignal( "OnDestroy" )
	titan.EndSignal( "OnDestroy" ) // pilot's titan has been robbed?

	pilot.SetInvulnerable()
	OnThreadEnd(
		function(): ( pilot )
		{
			if( IsAlive( pilot ) )
				pilot.ClearInvulnerable()
		}
	)

	wait duration
	//pilot.ClearInvulnerable() // fixed: if pilots're killed before titan lands their titan will stuck in the sky!
}

void function ForceStartTitan( entity titan, entity pilot, float delay )
{
	pilot.EndSignal( "OnDeath" )
	pilot.EndSignal( "OnDestroy" )
	titan.EndSignal( "OnDestroy" )

	OnThreadEnd(
		function():( titan, pilot )
		{
			if( IsAlive( pilot ) )
			{
				if( IsAlive( titan ) )
				{
					titan.SetOwner( pilot )
					NPCFollowsNPC( titan, pilot )
					// shared signals in _ai_pilots.gnut
					pilot.Signal( "StopRunsToEmbark" ) // pilot will still embark if they reached titan
					if( titan.ContextAction_IsBusy() ) // embarking?
						return
					// don't start titan handler. titan will follow the pilot
					if ( GetNPCHandlerForClass( "npc_pilot_elite" ) != null )
						thread GetNPCHandlerForClass( "npc_pilot_elite" )( pilot )
					pilot.SetNPCMoveSpeedScale( 1.25 ) // reset move speed
					pilot.DisableNPCFlag( NPC_IGNORE_ALL ) // pilot also start scan around

					thread StandUnboardedTitan( titan, true )
				}
			}
			else
			{
				if( IsAlive( titan ) ) // this titan have no owner!!
				{
					if( titan.GetTitanSoul().soul.seatedNpcPilot.isValid )
						return
					thread StandUnboardedTitan( titan, true )
				}
			}
		}
	)

	titan.WaitSignal( "TitanHotDropComplete" )
	wait delay
}

entity function ExtraSpawner_SpawnTitanForPilot( entity pilot, vector pos, vector rot, string spawnName = "" )
{
	// reworked to use an existing function
	entity titan = ExtraSpawner_SpawnTitan( pos, rot, pilot.GetTeam(), false, null, spawnName ) // the titan will wait before standing up, and it will use default titan handler
	NpcPilotSetPetTitan( pilot, titan )
	thread PetTitanOwnerLifeTimeCheck( titan, pilot ) // avoid titan being stuck in the sky! this happens if pilot died while titan dropping

	// make them be like auto titans
	titan.kv.WeaponProficiency = eWeaponProficiency.AVERAGE // normal proficiency
	//titan.SetCanBeMeleeExecuted( true ) // npc synced melee ignores this
	titan.SetBehaviorSelector( "behavior_mp_auto_titan" ) // since we want to make them be like auto titans, always use this

	return titan
}

void function PetTitanOwnerLifeTimeCheck( entity titan, entity owner )
{
	owner.EndSignal( "OnDeath" )
	owner.EndSignal( "OnDestroy" )
	titan.EndSignal( "OnDestroy" )

	table data = {}
	data.dropSuccess <- false

	OnThreadEnd(
		function(): ( titan, data )
		{
			if( data.dropSuccess ) // successfully dropped to ground, maybe it can stand up after owner died
				return
			if( IsValid( titan ) ) 
				titan.Destroy() // ded.
		}
	)

	titan.WaitSignal( "TitanHotDropComplete" )
	data.dropSuccess = true
}

function OnNpcPilotBecomesTitan( pilot, titan )
{
	expect entity( pilot )
	expect entity( titan )

	// only handle titans spawn from this file
	if ( !( titan in file.npcSpawnFromExtraSpawner ) )
		return

	ExtraSpawner_SetUpNPCEmbarkedTitan( titan )
	ApplySoulSettingsForNpcPilotEmbarking( titan ) // become smarter, since pilot has control of it

	// kinda annoying to have a info target all around them.
	//titan.SetAISettings( titan.GetAISettingsName() + "_bounty" ) // so they will show up a health bar, letting players know they're npc pilot controled
	//Highlight_ClearEnemyHighlight( titan ) // this resets highlights in modified sh_highlights
	// titan handler
	if ( GetNPCHandlerForClass( "npc_titan" ) != null )
		thread GetNPCHandlerForClass( "npc_titan" )( titan )
}

void function ExtraSpawner_SetUpNPCEmbarkedTitan( entity titan )
{
	titan.kv.WeaponProficiency = eWeaponProficiency.VERYGOOD // they can shoot very nice
	//titan.SetCanBeMeleeExecuted( false ) // code synced melee ignores this
	if ( MeleeSyncedNPC_IsTitanOnlyAllowedToExecuteWithNPCPilot() )
		titan.SetCapabilityFlag( bits_CAP_SYNCED_MELEE_ATTACK, false ) // disable synced melee behavior, we use melee_synced_npc
	TitanHealth_SetTitanCoreBuilderMultiplier( titan, 2.5 ) // want them get core abilities faster
}

function OnNpcTitanBecomesPilot( pilot, titan )
{
	expect entity( pilot )
	expect entity( titan )

	// only handle titans spawn from this file
	if ( !( titan in file.npcSpawnFromExtraSpawner ) )
		return

	// if titan is spawned by extraSpawner, pilot should also be marked
	file.npcSpawnFromExtraSpawner[ pilot ] <- true
	ExtraSpawner_SetUpNPCPilot( pilot )
	// pilot handler
	if ( GetNPCHandlerForClass( "npc_pilot_elite" ) != null )
		thread GetNPCHandlerForClass( "npc_pilot_elite" )( pilot )

	if ( IsValid( titan ) ) // disembarking, unfortunatelly this is not featured
	{
		entity titanSoul = titan.GetTitanSoul()
		if( !IsValid( titanSoul ) ) // defensive fix for titan.Destroy() situations
			return
		if ( pilot.GetTitle() != "" )
			titan.SetTitle( pilot.GetTitle() + " 的自動泰坦" ) // update title for disembarking or ejecting

		bool isEjecting = titanSoul.IsEjecting()
		if( isEjecting )
			thread NPCPilotEjectingAnimation( pilot )
		else // not ejecting, reset to normal behavior. this never happens cause there're no logic about npc pilot disembarking
		{
			titan.kv.WeaponProficiency = eWeaponProficiency.AVERAGE
			//titan.SetCanBeMeleeExecuted( true ) // npc synced melee ignores this
			titan.SetBehaviorSelector( "behavior_mp_auto_titan" )
			if ( MeleeSyncedNPC_IsTitanOnlyAllowedToExecuteWithNPCPilot() )
				titan.SetCapabilityFlag( bits_CAP_SYNCED_MELEE_ATTACK, true ) // restore synced melee for auto-titans
			TitanHealth_SetTitanCoreBuilderMultiplier( titan, 1.0 ) // reset core build speed to normal
		}

		// kinda annoying to have a info target all around them.
		//string aiSetFile = titan.GetAISettingsName()
		//titan.SetAISettings( aiSetFile.slice( 0, aiSetFile.len() - 7 ) ) // not ejecting, back to normal health bar
		//Highlight_ClearEnemyHighlight( titan ) // this resets highlights in modified sh_highlights
	}
}

void function NPCPilotEjectingAnimation( entity pilot )
{
	pilot.EndSignal( "OnDestroy" )
	pilot.EndSignal( "OnDeath" )
	
	OnThreadEnd
	(
		function(): ( pilot )
		{
			if ( IsValid( pilot ) )
				pilot.Anim_Stop()
		}
	)

	pilot.Anim_ScriptedPlayActivityByName( "ACT_FALL", true, 0.2 )
	while( !pilot.IsOnGround() )
		WaitFrame()
}

// modified things
//////////////////////////////////////////////////////////
// re-adjust damages for npc pilots!
const int PLAYER_TITAN_MELEE_DAMAGE_NPC_PILOT = 100
const int NPC_TITAN_MELEE_DAMAGE_NPC_PILOT = 300
const int TITAN_SOWRD_DAMAGE_NPC_PILOT = 250
const int TITAN_STEPPING_ON_DAMAGE_NPC_PILOT = 250

void function NPCPilotDamageAdjustments( entity pilot, var damageInfo )
{
	if ( !( pilot in file.npcSpawnFromExtraSpawner ) ) // pilot spawning from other files!
		return

	int damageSourceID = DamageInfo_GetDamageSourceIdentifier( damageInfo )
	int damageType = DamageInfo_GetCustomDamageType( damageInfo )
	entity attacker = DamageInfo_GetAttacker( damageInfo )
	if ( !IsValid( attacker ) )
		return
	if ( !attacker.IsTitan() )
		return

	// titan step
	if( damageSourceID == damagedef_titan_step ) 
		DamageInfo_SetDamage( damageInfo, TITAN_STEPPING_ON_DAMAGE_NPC_PILOT )

	// titan melee
	if( damageType & DF_MELEE || damageSourceID == eDamageSourceId.auto_titan_melee )
	{
		// player's titan melee
		if ( attacker.IsPlayer() )
		{
			// ronin sword
			if( damageSourceID == eDamageSourceId.melee_titan_sword ) 
				DamageInfo_SetDamage( damageInfo, TITAN_SOWRD_DAMAGE_NPC_PILOT )
			else
				DamageInfo_SetDamage( damageInfo, PLAYER_TITAN_MELEE_DAMAGE_NPC_PILOT )
		}

		// npc's titan melee
		if( attacker.IsNPC() ) 
			DamageInfo_SetDamage( damageInfo, NPC_TITAN_MELEE_DAMAGE_NPC_PILOT )
	}
}

void function ApplyNormalMeleeIdToNPCTitan( entity victim, var damageInfo )
{
	entity attacker = DamageInfo_GetAttacker( damageInfo )
    if( !IsValid( attacker ) )
        return
	if( !attacker.IsNPC() )
		return
    if( !attacker.IsTitan() )
        return
	if( !TitanHasNpcPilot( attacker ) )
		return
	// only handle npcs from this file
	if ( !( attacker in file.npcSpawnFromExtraSpawner ) )
		return
	
	// may no need to handle ronin sword, since ronin sometimes try to step on enemies
	int damageSource = eDamageSourceId.melee_titan_punch // default value
	entity meleeWeapon = attacker.GetMeleeWeapon() // melee weapon overrides
	if ( IsValid( meleeWeapon ) )
		damageSource = TitanMelee_GetMeleeDamageSourceIDForWeapon( meleeWeapon ) // modified function in sh_melee_titan.gnut
	
	DamageInfo_SetDamageSourceIdentifier( damageInfo, damageSource )
}

void function ProwlerMeleeDamageModifier( entity victim, var damageInfo )
{
	if ( !( victim in file.isProwlerSquadmate ) ) // npc is not a prowler squad member!
		return

	entity attacker = DamageInfo_GetAttacker( damageInfo )
    if( !IsValid( attacker ) )
        return
	if( !attacker.IsNPC() )
		return

	float modelScale = float( attacker.kv.modelscale )
	float damageScale = 1.0
	if ( modelScale < 1 )
		damageScale = modelScale * 0.75 // take less damage from smaller prowlers
	DamageInfo_ScaleDamage( damageInfo, damageScale )
}

void function ExtraSpawner_PilotHandler( entity pilot )
{
	// Signals for controlling
	pilot.Signal( "StopDefaultHandler" )
	pilot.EndSignal( "StopDefaultHandler" )

	// Setup AI, no need for now
	//pilot.EnableNPCFlag( NPC_ALLOW_PATROL | NPC_ALLOW_INVESTIGATE | NPC_ALLOW_HAND_SIGNALS | NPC_ALLOW_FLEE )
	int team = pilot.GetTeam()
	array<entity> points

	pilot.AssaultSetGoalRadius( 1600 ) // 1600 is minimum for npc_stalker, works fine for others
	// show on enemy radar, unfortunatelly cl_minimap won't track npc_pilot_elite
	AddMinimapForNPC( pilot, true )
	
	// Every 5 - 15 secs get a closest target and go to them
	while ( true )
	{	
		WaitFrame() // always wait a frame before each loop
		
		// Check if alive
		if ( !IsAlive( pilot ) )
			return
		
		// Get point and send guy to it
		points = [] // clean up last points
		points.extend( GetNPCArrayOfEnemies( team ) )
		points.extend( GetPlayerArrayOfEnemies_Alive( team ) )
		if ( points.len() == 0 )
			continue

		entity enemy = GetClosest2D( points, pilot.GetOrigin() )
		if ( !IsValid( enemy ) )
			continue
		vector ornull clampedPos = NavMesh_ClampPointForAI( enemy.GetOrigin(), pilot )
		if ( clampedPos == null )
			continue
		expect vector( clampedPos )
		pilot.AssaultPoint( clampedPos )

		wait RandomFloatRange( 5.0, 15.0 ) // random wait
	}
}

void function ExtraSpawner_TitanHandler( entity titan )
{
	// Signals for controlling
	titan.Signal( "StopDefaultHandler" )
	titan.EndSignal( "StopDefaultHandler" )

	int team = titan.GetTeam()
	array<entity> points

	titan.AssaultSetGoalRadius( 1600 ) // 1600 is minimum for npc_stalker, works fine for others
	// show on enemy radar
	AddMinimapForNPC( titan, false )
	
	// Every 10 - 20 secs get a closest target and go to them
	while ( true )
	{	
		WaitFrame() // always wait a frame before each loop

		// Check if alive
		if ( !IsAlive( titan ) )
			return
		
		// Get point and send guy to it
		points = [] // clean up last points
		// we mostly search for heavy armor targets
		bool foundHeavyArmorTarget = false
		foreach ( entity npc in GetNPCArrayOfEnemies( team ) )
		{
			if ( npc.GetArmorType() == ARMOR_TYPE_HEAVY )
			{
				points.append( npc )
				foundHeavyArmorTarget = true
			}
		}
		foreach ( entity player in GetPlayerArrayOfEnemies_Alive( team ) )
		{
			if ( player.IsTitan() )
			{
				points.append( player )
				foundHeavyArmorTarget = true
			}
		}
		if ( !foundHeavyArmorTarget ) // can't find any heavyarmor target!
		{
			// use all targets instead
			points.extend( GetNPCArrayOfEnemies( team ) )
			points.extend( GetPlayerArrayOfEnemies_Alive( team ) )
		}
		if ( points.len() == 0 ) // no points valid!
			continue

		entity enemy = GetClosest2D( points, titan.GetOrigin() )
		if ( !IsValid( enemy ) )
			continue
		vector ornull clampedPos = NavMesh_ClampPointForAI( enemy.GetOrigin(), titan )
		if ( clampedPos == null )
			continue
		expect vector( clampedPos )
		titan.AssaultPoint( clampedPos )

		wait RandomFloatRange( 10.0, 20.0 ) // random wait
	}
}

const float CARE_PACKAGE_LIFETIME = 30
const float CARE_PACKAGE_WAITTIME = 5
void function ExtraSpawner_SpawnCarePackageToGetWeapons( vector pos, vector rot, float lifeTime = CARE_PACKAGE_LIFETIME, float waitTime = CARE_PACKAGE_WAITTIME )
{
	//thread DropWeaponAlert( pos, 500, 200 )
	thread CarePackage_SpawnPoint( pos, 10 )
	thread ExtraSpawner_SpawnCarePackageToGetWeapons_Threaded( pos, rot, lifeTime, waitTime )
}

void function ExtraSpawner_SpawnCarePackageToGetWeapons_Threaded( vector pos, vector rot, float lifeTime, float waitTime )
{
	file.usedplayer.clear()
	wait waitTime
	entity pod = CreateDropPod( pos, <0,0,0> )
	pod.EndSignal( "OnDestroy" )
	Highlight_SetOwnedHighlight( pod, "friendly_ai" )

	//InitFireteamDropPod( pod )

	// it takes 5s to drop
	waitthread LaunchAnimDropPod( pod, "pod_testpath", pos, rot )

	pod.SetUsable()
	pod.SetUsableByGroup( "pilot" )
	pod.SetUsePrompts( "按住 %use% 以獲取武器", "按下 %use% 獲取武器" )
	AddCallback_OnUseEntity( pod , GiveAirDropWeapon )

	HighlightDropPod( pod )
	pod.SetModel( CAREPACKAGE_MODEL )
    
    wait lifeTime

	//pod.Destroy()
	pod.UnsetUsable() // don't let dissolving pod able to be used
	pod.NotSolid() // clear collision
	DisableDropPodHighlight( pod )
	pod.Dissolve( ENTITY_DISSOLVE_CORE, Vector( 0, 0, 0 ), 500 )
}

// copied from cl_replacement_titan_hud.gnut
void function CarePackage_SpawnPoint( vector origin, float impactTime )
{
	array<entity> targetEffects = []
	vector surfaceNormal = < 0, 0, 1 >

	int index = GetParticleSystemIndex( $"P_ar_titan_droppoint" )

	entity targetEffect = StartParticleEffectInWorld_ReturnEntity( index, origin, surfaceNormal )
	EffectSetControlPointVector( targetEffect, 1, < 0,190,0 > ) // green
	targetEffect.DisableHibernation()

	wait impactTime

	if ( IsValid( targetEffect ) )
		EffectStop( targetEffect )
}

function GiveAirDropWeapon( pod , player )
{
	expect entity( player )
	vector pos = player.GetOrigin()

	if( file.usedplayer.contains( player ) )
	{
		//SendHudMessage(player, "Once Robbed Weapon from Care Package\nPlease Wait for Next Delivery",  -1, 0.3, 255, 255, 0, 255, 0.15, 3, 1)
		SendHudMessage( player, "已獲取本次補給艙\n請等待下一輪",  -1, 0.3, 255, 255, 0, 255, 0.15, 3, 1 )
		return
	}
    //DropModdedWeapons( WEAPONS, pos, MODS )
	if( player.GetMainWeapons().len() == 3 )
		player.DropWeapon( player.GetMainWeapons()[2] ) // was [1], for the newest version, drop the grenadier!
	//GiveModdedWeapons( player, WEAPONS, MODS )
	GiveModdedWeapons( player, file.carePackageWeapons )
	RestorePlayerAmmo( player )
    //SendHudMessage(player, "Got Weapon from Care Package",  -1, 0.3, 255, 255, 0, 255, 0.15, 3, 1)
    SendHudMessage( player, "已從補給艙補充彈藥",  -1, 0.3, 255, 255, 0, 255, 0.15, 3, 1 )
	file.usedplayer.append( player )
	player.Signal( "PlayerUsedCarePackage" )
}

// now allowing every weapon to have a custom mod
void function GiveModdedWeapons( entity player, array<string> weapons )
{
	string weaponName = weapons[ RandomInt(weapons.len()) ]
	array<string> mods = []
	if ( weaponName in file.carePackageWeaponMods )
		mods = file.carePackageWeaponMods[weaponName]
	player.GiveWeapon( weaponName, mods )
	player.SetActiveWeaponByName( weaponName )
}

void function RestorePlayerAmmo( entity player )
{
	foreach( entity mainWeapon in player.GetMainWeapons() )
	{
		player.SetSuitGrapplePower( 100.0 ) // restore grapple power
		// this will restore anti-titan's ammo
		try // should do a try-catch for safely adding other classes
		{
			// use weapon.GetWeaponSettingInt( eWeaponVar.ammo_stockpile_max ) to get max ammo
			// current restore 3 mags
			//mainWeapon.SetWeaponPrimaryAmmoCount( mainWeapon.GetWeaponPrimaryAmmoCount() + mainWeapon.GetWeaponPrimaryClipCountMax() * 3 )
			// updated, restore all ammo
			mainWeapon.SetWeaponPrimaryAmmoCount( 9999 )
		}
		catch(ex){}
		try{ mainWeapon.SetWeaponPrimaryClipCount( mainWeapon.GetWeaponPrimaryClipCountMax() ) }
		catch(ex1){}
	}
	foreach( entity offhand in player.GetOffhandWeapons() )
	{
		// this will restore ordnances
		try // should do a try-catch for safely adding other classes
		{
			offhand.SetWeaponPrimaryClipCount( offhand.GetWeaponPrimaryClipCountMax() )
		}
		catch(ex){}
	}
}

void function HighlightWeaponAmped( entity weapon )
{
	if ( weapon.IsLoadoutPickup() )
	{
		Highlight_SetOwnedHighlight( weapon, "sp_loadout_pickup" )
		Highlight_SetNeutralHighlight( weapon, "sp_loadout_pickup" )
	}
	else
	{
		Highlight_SetOwnedHighlight( weapon, "enemy_boss_bounty" )
		Highlight_SetNeutralHighlight( weapon, "enemy_boss_bounty" )
	}
}

void function HighlightDropPod( entity pod )
{
	Highlight_SetOwnedHighlight( pod, "enemy_boss_bounty" )
	Highlight_SetNeutralHighlight( pod, "enemy_boss_bounty" )
}

void function DisableDropPodHighlight( entity pod )
{
	Highlight_ClearOwnedHighlight( pod )
	Highlight_ClearNeutralHighlight( pod )
}

const float REAPER_WARPFALL_DELAY = 4.7 // same as fd does
void function ExtraSpawner_SpawnReaperCanLaunchTicks( vector pos, vector rot, int team, string reaperSettings = "npc_super_spectre_aitdm", string tickSettings = "npc_frag_drone" )
{
	// nessie fix
	float reaperLandTime = REAPER_WARPFALL_DELAY + 1.2 // reaper takes ~1.2s to warpfall
	thread HotDrop_Spawnpoint( pos, team, reaperLandTime, true, damagedef_reaper_fall ) // add friendly warning for this special kind of reaper

	wait REAPER_WARPFALL_DELAY
	entity reaper = CreateSuperSpectre( team, pos, rot )
	reaper.EndSignal( "OnDestroy" )
	// reaper highlight
	Highlight_SetFriendlyHighlight( reaper, "sp_enemy_pilot" )
	reaper.Highlight_SetParam( 1, 0, < 1,1,1 > )
	reaper.e.hasDefaultEnemyHighlight = true // mark them as hasDefaultHighlight, so they'll save highlights after phase shift
	SetDefaultMPEnemyHighlight( reaper )

	SetSpawnOption_Titanfall( reaper )
	SetSpawnOption_Warpfall( reaper )
	
	SetSpawnOption_AISettings( reaper, reaperSettings )
	
	HideName( reaper ) // prevent flash a name onto it

	file.npcSpawnFromExtraSpawner[ reaper ] <- true
	DispatchSpawn( reaper )

	reaper.WaitSignal( "WarpfallComplete" )
	ShowName( reaper ) // show name again after drop
	// non-fd mode don't support stational point, write my own one
	//thread ReaperMinionLauncherThink( reaper, tickSettings ) 
	thread ExtraSpawner_ReaperTickLaunchThink( reaper, tickSettings )
	
	// modified _ai_superspectre.gnut, extremely powerful reaper
	SuperSpectre_AddNukeDeath( reaper ) // force this reaper to nuke on death without having to change aisettings
	//SuperSpectre_SetDropBatteryOnDeath( reaper, true ) // now supports mp. since they're very powerful, give some reward?
	SuperSpectre_SetNukeDeathThreshold( reaper, 9999 ) // they'll always try to nuke
	SuperSpectre_SetForcedKilledByTitans( reaper, false ) // they won't be disarmed by titans, always try to nuke
	SuperSpectre_SetSelfAsNukeAttacker( reaper, true ) // the nuke's attacker will always be the reaper
	SuperSpectre_SetNukeExplosionDamageEffect( 
		reaper, 		// current reaper
		5, 				// explosion count
		0.8, 			// explosion duration, end the nuke before reaper gets destroyed, so it won't deal friendly fire
		85, 			// damage
		700, 			// damage heavy armor
		330, 			// inner radius
		430, 			// outer radius
		SF_ENVEXPLOSION_MASK_BRUSHONLY,		// explosion flags
		50000,			// explosion force
		DF_RAGDOLL | DF_EXPLOSION			// script damage flags
	)
	SuperSpectre_SetSpawnerTickExplodeOnOwnerDeath( reaper, true ) // clean up their ticks using a modified way
	//SuperSpectre_SetSpawnerTickMaxCount( reaper, 8 ) // spawn 8 ticks per reaper

	// reaper handler
	if ( GetNPCHandlerForClass( "npc_super_spectre" ) != null )
		thread GetNPCHandlerForClass( "npc_super_spectre" )( reaper )
}

void function ExtraSpawner_ReaperTickLaunchThink( entity reaper, string tickType )
{
	reaper.EndSignal( "OnDeath" )

	wait 10 // startup time
	bool lastLaunchSucceeded = false // if we succeeded at last launch, we wait a longer time before next launch
	while ( true )
	{
		if ( lastLaunchSucceeded ) // succeeded launch
		{
			lastLaunchSucceeded = false
			wait RandomFloatRange( 25.0, 40.0 ) // every 25 - 40 secs try to do a tickLaunch, simple right?
		}
		WaitFrame() // keep letting them launch!

		//printt( reaper,"REAPER TICK LAUNCH:", reaper.GetOrigin() )
		waitthread Reaper_LaunchFragDrone_Think( reaper, tickType )
		//printt( reaper,"REAPER END TICK LAUNCH:", reaper.GetOrigin() )
		if ( GetScriptManagedEntArrayLen( reaper.ai.activeMinionEntArrayID ) >= 1 ) // at least launched one tick
			lastLaunchSucceeded = true // mark as succeeded
		while ( GetScriptManagedEntArrayLen( reaper.ai.activeMinionEntArrayID ) > 2 )
			WaitFrame()
	}
}

// Same as SquadHandler, just for reapers
void function ExtraSpawner_ReaperHandler( entity reaper )
{
	// Signals for controlling
	reaper.Signal( "StopDefaultHandler" )
	reaper.EndSignal( "StopDefaultHandler" )

	int team = reaper.GetTeam()
	array<entity> points

	// show on enmey radar
	AddMinimapForNPC( reaper, false )
	
	reaper.AssaultSetGoalRadius( 500 ) // goal radius
	
	// Every 10 - 20 secs get a closest target and go to them
	while( true )
	{
		WaitFrame() // always wait before each loop!

		// Check if alive
		if ( !IsAlive( reaper ) )
			return

		points = [] // clean up last point
		points.extend( GetNPCArrayOfEnemies( team ) )
		points.extend( GetPlayerArrayOfEnemies_Alive( team ) )
		ArrayRemoveDead( points ) // remove dead targets
		if ( points.len() == 0 )
			continue

		entity enemy = GetClosest2D( points, reaper.GetOrigin() )
		if ( !IsValid( enemy ) )
			continue
		vector ornull clampedPos = NavMesh_ClampPointForAI( enemy.GetOrigin(), reaper )
		if ( clampedPos == null )
			continue
		expect vector( clampedPos )
		reaper.AssaultPoint( clampedPos )

		wait RandomFloatRange( 10.0, 20.0 )
	}
}